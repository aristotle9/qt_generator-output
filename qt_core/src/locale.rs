/// C++ type: <span style='color: green;'>```QLocale::Country```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum Country {
  /// C++ enum variant: <span style='color: green;'>```AnyCountry = 0```</span>
  AnyCountry = 0,
  /// C++ enum variant: <span style='color: green;'>```Afghanistan = 1```</span>
  Afghanistan = 1,
  /// C++ enum variant: <span style='color: green;'>```Albania = 2```</span>
  Albania = 2,
  /// C++ enum variant: <span style='color: green;'>```Algeria = 3```</span>
  Algeria = 3,
  /// C++ enum variant: <span style='color: green;'>```AmericanSamoa = 4```</span>
  AmericanSamoa = 4,
  /// C++ enum variant: <span style='color: green;'>```Andorra = 5```</span>
  Andorra = 5,
  /// C++ enum variant: <span style='color: green;'>```Angola = 6```</span>
  Angola = 6,
  /// C++ enum variant: <span style='color: green;'>```Anguilla = 7```</span>
  Anguilla = 7,
  /// C++ enum variant: <span style='color: green;'>```Antarctica = 8```</span>
  Antarctica = 8,
  /// C++ enum variant: <span style='color: green;'>```AntiguaAndBarbuda = 9```</span>
  AntiguaAndBarbuda = 9,
  /// C++ enum variant: <span style='color: green;'>```Argentina = 10```</span>
  Argentina = 10,
  /// C++ enum variant: <span style='color: green;'>```Armenia = 11```</span>
  Armenia = 11,
  /// C++ enum variant: <span style='color: green;'>```Aruba = 12```</span>
  Aruba = 12,
  /// C++ enum variant: <span style='color: green;'>```Australia = 13```</span>
  Australia = 13,
  /// C++ enum variant: <span style='color: green;'>```Austria = 14```</span>
  Austria = 14,
  /// C++ enum variant: <span style='color: green;'>```Azerbaijan = 15```</span>
  Azerbaijan = 15,
  /// C++ enum variant: <span style='color: green;'>```Bahamas = 16```</span>
  Bahamas = 16,
  /// C++ enum variant: <span style='color: green;'>```Bahrain = 17```</span>
  Bahrain = 17,
  /// C++ enum variant: <span style='color: green;'>```Bangladesh = 18```</span>
  Bangladesh = 18,
  /// C++ enum variant: <span style='color: green;'>```Barbados = 19```</span>
  Barbados = 19,
  /// C++ enum variant: <span style='color: green;'>```Belarus = 20```</span>
  Belarus = 20,
  /// C++ enum variant: <span style='color: green;'>```Belgium = 21```</span>
  Belgium = 21,
  /// C++ enum variant: <span style='color: green;'>```Belize = 22```</span>
  Belize = 22,
  /// C++ enum variant: <span style='color: green;'>```Benin = 23```</span>
  Benin = 23,
  /// C++ enum variant: <span style='color: green;'>```Bermuda = 24```</span>
  Bermuda = 24,
  /// C++ enum variant: <span style='color: green;'>```Bhutan = 25```</span>
  Bhutan = 25,
  /// C++ enum variant: <span style='color: green;'>```Bolivia = 26```</span>
  Bolivia = 26,
  /// C++ enum variant: <span style='color: green;'>```BosniaAndHerzegowina = 27```</span>
  BosniaAndHerzegowina = 27,
  /// C++ enum variant: <span style='color: green;'>```Botswana = 28```</span>
  Botswana = 28,
  /// C++ enum variant: <span style='color: green;'>```BouvetIsland = 29```</span>
  BouvetIsland = 29,
  /// C++ enum variant: <span style='color: green;'>```Brazil = 30```</span>
  Brazil = 30,
  /// C++ enum variant: <span style='color: green;'>```BritishIndianOceanTerritory = 31```</span>
  BritishIndianOceanTerritory = 31,
  /// C++ enum variant: <span style='color: green;'>```Brunei = 32```</span>
  Brunei = 32,
  /// C++ enum variant: <span style='color: green;'>```Bulgaria = 33```</span>
  Bulgaria = 33,
  /// C++ enum variant: <span style='color: green;'>```BurkinaFaso = 34```</span>
  BurkinaFaso = 34,
  /// C++ enum variant: <span style='color: green;'>```Burundi = 35```</span>
  Burundi = 35,
  /// C++ enum variant: <span style='color: green;'>```Cambodia = 36```</span>
  Cambodia = 36,
  /// C++ enum variant: <span style='color: green;'>```Cameroon = 37```</span>
  Cameroon = 37,
  /// C++ enum variant: <span style='color: green;'>```Canada = 38```</span>
  Canada = 38,
  /// C++ enum variant: <span style='color: green;'>```CapeVerde = 39```</span>
  CapeVerde = 39,
  /// C++ enum variant: <span style='color: green;'>```CaymanIslands = 40```</span>
  CaymanIslands = 40,
  /// C++ enum variant: <span style='color: green;'>```CentralAfricanRepublic = 41```</span>
  CentralAfricanRepublic = 41,
  /// C++ enum variant: <span style='color: green;'>```Chad = 42```</span>
  Chad = 42,
  /// C++ enum variant: <span style='color: green;'>```Chile = 43```</span>
  Chile = 43,
  /// C++ enum variant: <span style='color: green;'>```China = 44```</span>
  China = 44,
  /// C++ enum variant: <span style='color: green;'>```ChristmasIsland = 45```</span>
  ChristmasIsland = 45,
  /// C++ enum variant: <span style='color: green;'>```CocosIslands = 46```</span>
  CocosIslands = 46,
  /// C++ enum variant: <span style='color: green;'>```Colombia = 47```</span>
  Colombia = 47,
  /// C++ enum variant: <span style='color: green;'>```Comoros = 48```</span>
  Comoros = 48,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```CongoKinshasa = 49```</span>
  /// - <span style='color: green;'>```DemocraticRepublicOfCongo = 49```</span>
  ///
  CongoKinshasa = 49,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```CongoBrazzaville = 50```</span>
  /// - <span style='color: green;'>```PeoplesRepublicOfCongo = 50```</span>
  ///
  CongoBrazzaville = 50,
  /// C++ enum variant: <span style='color: green;'>```CookIslands = 51```</span>
  CookIslands = 51,
  /// C++ enum variant: <span style='color: green;'>```CostaRica = 52```</span>
  CostaRica = 52,
  /// C++ enum variant: <span style='color: green;'>```IvoryCoast = 53```</span>
  IvoryCoast = 53,
  /// C++ enum variant: <span style='color: green;'>```Croatia = 54```</span>
  Croatia = 54,
  /// C++ enum variant: <span style='color: green;'>```Cuba = 55```</span>
  Cuba = 55,
  /// C++ enum variant: <span style='color: green;'>```Cyprus = 56```</span>
  Cyprus = 56,
  /// C++ enum variant: <span style='color: green;'>```CzechRepublic = 57```</span>
  CzechRepublic = 57,
  /// C++ enum variant: <span style='color: green;'>```Denmark = 58```</span>
  Denmark = 58,
  /// C++ enum variant: <span style='color: green;'>```Djibouti = 59```</span>
  Djibouti = 59,
  /// C++ enum variant: <span style='color: green;'>```Dominica = 60```</span>
  Dominica = 60,
  /// C++ enum variant: <span style='color: green;'>```DominicanRepublic = 61```</span>
  DominicanRepublic = 61,
  /// C++ enum variant: <span style='color: green;'>```EastTimor = 62```</span>
  EastTimor = 62,
  /// C++ enum variant: <span style='color: green;'>```Ecuador = 63```</span>
  Ecuador = 63,
  /// C++ enum variant: <span style='color: green;'>```Egypt = 64```</span>
  Egypt = 64,
  /// C++ enum variant: <span style='color: green;'>```ElSalvador = 65```</span>
  ElSalvador = 65,
  /// C++ enum variant: <span style='color: green;'>```EquatorialGuinea = 66```</span>
  EquatorialGuinea = 66,
  /// C++ enum variant: <span style='color: green;'>```Eritrea = 67```</span>
  Eritrea = 67,
  /// C++ enum variant: <span style='color: green;'>```Estonia = 68```</span>
  Estonia = 68,
  /// C++ enum variant: <span style='color: green;'>```Ethiopia = 69```</span>
  Ethiopia = 69,
  /// C++ enum variant: <span style='color: green;'>```FalklandIslands = 70```</span>
  FalklandIslands = 70,
  /// C++ enum variant: <span style='color: green;'>```FaroeIslands = 71```</span>
  FaroeIslands = 71,
  /// C++ enum variant: <span style='color: green;'>```Fiji = 72```</span>
  Fiji = 72,
  /// C++ enum variant: <span style='color: green;'>```Finland = 73```</span>
  Finland = 73,
  /// C++ enum variant: <span style='color: green;'>```France = 74```</span>
  France = 74,
  /// C++ enum variant: <span style='color: green;'>```Guernsey = 75```</span>
  Guernsey = 75,
  /// C++ enum variant: <span style='color: green;'>```FrenchGuiana = 76```</span>
  FrenchGuiana = 76,
  /// C++ enum variant: <span style='color: green;'>```FrenchPolynesia = 77```</span>
  FrenchPolynesia = 77,
  /// C++ enum variant: <span style='color: green;'>```FrenchSouthernTerritories = 78```</span>
  FrenchSouthernTerritories = 78,
  /// C++ enum variant: <span style='color: green;'>```Gabon = 79```</span>
  Gabon = 79,
  /// C++ enum variant: <span style='color: green;'>```Gambia = 80```</span>
  Gambia = 80,
  /// C++ enum variant: <span style='color: green;'>```Georgia = 81```</span>
  Georgia = 81,
  /// C++ enum variant: <span style='color: green;'>```Germany = 82```</span>
  Germany = 82,
  /// C++ enum variant: <span style='color: green;'>```Ghana = 83```</span>
  Ghana = 83,
  /// C++ enum variant: <span style='color: green;'>```Gibraltar = 84```</span>
  Gibraltar = 84,
  /// C++ enum variant: <span style='color: green;'>```Greece = 85```</span>
  Greece = 85,
  /// C++ enum variant: <span style='color: green;'>```Greenland = 86```</span>
  Greenland = 86,
  /// C++ enum variant: <span style='color: green;'>```Grenada = 87```</span>
  Grenada = 87,
  /// C++ enum variant: <span style='color: green;'>```Guadeloupe = 88```</span>
  Guadeloupe = 88,
  /// C++ enum variant: <span style='color: green;'>```Guam = 89```</span>
  Guam = 89,
  /// C++ enum variant: <span style='color: green;'>```Guatemala = 90```</span>
  Guatemala = 90,
  /// C++ enum variant: <span style='color: green;'>```Guinea = 91```</span>
  Guinea = 91,
  /// C++ enum variant: <span style='color: green;'>```GuineaBissau = 92```</span>
  GuineaBissau = 92,
  /// C++ enum variant: <span style='color: green;'>```Guyana = 93```</span>
  Guyana = 93,
  /// C++ enum variant: <span style='color: green;'>```Haiti = 94```</span>
  Haiti = 94,
  /// C++ enum variant: <span style='color: green;'>```HeardAndMcDonaldIslands = 95```</span>
  HeardAndMcDonaldIslands = 95,
  /// C++ enum variant: <span style='color: green;'>```Honduras = 96```</span>
  Honduras = 96,
  /// C++ enum variant: <span style='color: green;'>```HongKong = 97```</span>
  HongKong = 97,
  /// C++ enum variant: <span style='color: green;'>```Hungary = 98```</span>
  Hungary = 98,
  /// C++ enum variant: <span style='color: green;'>```Iceland = 99```</span>
  Iceland = 99,
  /// C++ enum variant: <span style='color: green;'>```India = 100```</span>
  India = 100,
  /// C++ enum variant: <span style='color: green;'>```Indonesia = 101```</span>
  Indonesia = 101,
  /// C++ enum variant: <span style='color: green;'>```Iran = 102```</span>
  Iran = 102,
  /// C++ enum variant: <span style='color: green;'>```Iraq = 103```</span>
  Iraq = 103,
  /// C++ enum variant: <span style='color: green;'>```Ireland = 104```</span>
  Ireland = 104,
  /// C++ enum variant: <span style='color: green;'>```Israel = 105```</span>
  Israel = 105,
  /// C++ enum variant: <span style='color: green;'>```Italy = 106```</span>
  Italy = 106,
  /// C++ enum variant: <span style='color: green;'>```Jamaica = 107```</span>
  Jamaica = 107,
  /// C++ enum variant: <span style='color: green;'>```Japan = 108```</span>
  Japan = 108,
  /// C++ enum variant: <span style='color: green;'>```Jordan = 109```</span>
  Jordan = 109,
  /// C++ enum variant: <span style='color: green;'>```Kazakhstan = 110```</span>
  Kazakhstan = 110,
  /// C++ enum variant: <span style='color: green;'>```Kenya = 111```</span>
  Kenya = 111,
  /// C++ enum variant: <span style='color: green;'>```Kiribati = 112```</span>
  Kiribati = 112,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```NorthKorea = 113```</span>
  /// - <span style='color: green;'>```DemocraticRepublicOfKorea = 113```</span>
  ///
  NorthKorea = 113,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```SouthKorea = 114```</span>
  /// - <span style='color: green;'>```RepublicOfKorea = 114```</span>
  ///
  SouthKorea = 114,
  /// C++ enum variant: <span style='color: green;'>```Kuwait = 115```</span>
  Kuwait = 115,
  /// C++ enum variant: <span style='color: green;'>```Kyrgyzstan = 116```</span>
  Kyrgyzstan = 116,
  /// C++ enum variant: <span style='color: green;'>```Laos = 117```</span>
  Laos = 117,
  /// C++ enum variant: <span style='color: green;'>```Latvia = 118```</span>
  Latvia = 118,
  /// C++ enum variant: <span style='color: green;'>```Lebanon = 119```</span>
  Lebanon = 119,
  /// C++ enum variant: <span style='color: green;'>```Lesotho = 120```</span>
  Lesotho = 120,
  /// C++ enum variant: <span style='color: green;'>```Liberia = 121```</span>
  Liberia = 121,
  /// C++ enum variant: <span style='color: green;'>```Libya = 122```</span>
  Libya = 122,
  /// C++ enum variant: <span style='color: green;'>```Liechtenstein = 123```</span>
  Liechtenstein = 123,
  /// C++ enum variant: <span style='color: green;'>```Lithuania = 124```</span>
  Lithuania = 124,
  /// C++ enum variant: <span style='color: green;'>```Luxembourg = 125```</span>
  Luxembourg = 125,
  /// C++ enum variant: <span style='color: green;'>```Macau = 126```</span>
  Macau = 126,
  /// C++ enum variant: <span style='color: green;'>```Macedonia = 127```</span>
  Macedonia = 127,
  /// C++ enum variant: <span style='color: green;'>```Madagascar = 128```</span>
  Madagascar = 128,
  /// C++ enum variant: <span style='color: green;'>```Malawi = 129```</span>
  Malawi = 129,
  /// C++ enum variant: <span style='color: green;'>```Malaysia = 130```</span>
  Malaysia = 130,
  /// C++ enum variant: <span style='color: green;'>```Maldives = 131```</span>
  Maldives = 131,
  /// C++ enum variant: <span style='color: green;'>```Mali = 132```</span>
  Mali = 132,
  /// C++ enum variant: <span style='color: green;'>```Malta = 133```</span>
  Malta = 133,
  /// C++ enum variant: <span style='color: green;'>```MarshallIslands = 134```</span>
  MarshallIslands = 134,
  /// C++ enum variant: <span style='color: green;'>```Martinique = 135```</span>
  Martinique = 135,
  /// C++ enum variant: <span style='color: green;'>```Mauritania = 136```</span>
  Mauritania = 136,
  /// C++ enum variant: <span style='color: green;'>```Mauritius = 137```</span>
  Mauritius = 137,
  /// C++ enum variant: <span style='color: green;'>```Mayotte = 138```</span>
  Mayotte = 138,
  /// C++ enum variant: <span style='color: green;'>```Mexico = 139```</span>
  Mexico = 139,
  /// C++ enum variant: <span style='color: green;'>```Micronesia = 140```</span>
  Micronesia = 140,
  /// C++ enum variant: <span style='color: green;'>```Moldova = 141```</span>
  Moldova = 141,
  /// C++ enum variant: <span style='color: green;'>```Monaco = 142```</span>
  Monaco = 142,
  /// C++ enum variant: <span style='color: green;'>```Mongolia = 143```</span>
  Mongolia = 143,
  /// C++ enum variant: <span style='color: green;'>```Montserrat = 144```</span>
  Montserrat = 144,
  /// C++ enum variant: <span style='color: green;'>```Morocco = 145```</span>
  Morocco = 145,
  /// C++ enum variant: <span style='color: green;'>```Mozambique = 146```</span>
  Mozambique = 146,
  /// C++ enum variant: <span style='color: green;'>```Myanmar = 147```</span>
  Myanmar = 147,
  /// C++ enum variant: <span style='color: green;'>```Namibia = 148```</span>
  Namibia = 148,
  /// C++ enum variant: <span style='color: green;'>```NauruCountry = 149```</span>
  NauruCountry = 149,
  /// C++ enum variant: <span style='color: green;'>```Nepal = 150```</span>
  Nepal = 150,
  /// C++ enum variant: <span style='color: green;'>```Netherlands = 151```</span>
  Netherlands = 151,
  /// C++ enum variant: <span style='color: green;'>```CuraSao = 152```</span>
  CuraSao = 152,
  /// C++ enum variant: <span style='color: green;'>```NewCaledonia = 153```</span>
  NewCaledonia = 153,
  /// C++ enum variant: <span style='color: green;'>```NewZealand = 154```</span>
  NewZealand = 154,
  /// C++ enum variant: <span style='color: green;'>```Nicaragua = 155```</span>
  Nicaragua = 155,
  /// C++ enum variant: <span style='color: green;'>```Niger = 156```</span>
  Niger = 156,
  /// C++ enum variant: <span style='color: green;'>```Nigeria = 157```</span>
  Nigeria = 157,
  /// C++ enum variant: <span style='color: green;'>```Niue = 158```</span>
  Niue = 158,
  /// C++ enum variant: <span style='color: green;'>```NorfolkIsland = 159```</span>
  NorfolkIsland = 159,
  /// C++ enum variant: <span style='color: green;'>```NorthernMarianaIslands = 160```</span>
  NorthernMarianaIslands = 160,
  /// C++ enum variant: <span style='color: green;'>```Norway = 161```</span>
  Norway = 161,
  /// C++ enum variant: <span style='color: green;'>```Oman = 162```</span>
  Oman = 162,
  /// C++ enum variant: <span style='color: green;'>```Pakistan = 163```</span>
  Pakistan = 163,
  /// C++ enum variant: <span style='color: green;'>```Palau = 164```</span>
  Palau = 164,
  /// C++ enum variant: <span style='color: green;'>```PalestinianTerritories = 165```</span>
  PalestinianTerritories = 165,
  /// C++ enum variant: <span style='color: green;'>```Panama = 166```</span>
  Panama = 166,
  /// C++ enum variant: <span style='color: green;'>```PapuaNewGuinea = 167```</span>
  PapuaNewGuinea = 167,
  /// C++ enum variant: <span style='color: green;'>```Paraguay = 168```</span>
  Paraguay = 168,
  /// C++ enum variant: <span style='color: green;'>```Peru = 169```</span>
  Peru = 169,
  /// C++ enum variant: <span style='color: green;'>```Philippines = 170```</span>
  Philippines = 170,
  /// C++ enum variant: <span style='color: green;'>```Pitcairn = 171```</span>
  Pitcairn = 171,
  /// C++ enum variant: <span style='color: green;'>```Poland = 172```</span>
  Poland = 172,
  /// C++ enum variant: <span style='color: green;'>```Portugal = 173```</span>
  Portugal = 173,
  /// C++ enum variant: <span style='color: green;'>```PuertoRico = 174```</span>
  PuertoRico = 174,
  /// C++ enum variant: <span style='color: green;'>```Qatar = 175```</span>
  Qatar = 175,
  /// C++ enum variant: <span style='color: green;'>```Reunion = 176```</span>
  Reunion = 176,
  /// C++ enum variant: <span style='color: green;'>```Romania = 177```</span>
  Romania = 177,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Russia = 178```</span>
  /// - <span style='color: green;'>```RussianFederation = 178```</span>
  ///
  Russia = 178,
  /// C++ enum variant: <span style='color: green;'>```Rwanda = 179```</span>
  Rwanda = 179,
  /// C++ enum variant: <span style='color: green;'>```SaintKittsAndNevis = 180```</span>
  SaintKittsAndNevis = 180,
  /// C++ enum variant: <span style='color: green;'>```SaintLucia = 181```</span>
  SaintLucia = 181,
  /// C++ enum variant: <span style='color: green;'>```SaintVincentAndTheGrenadines = 182```</span>
  SaintVincentAndTheGrenadines = 182,
  /// C++ enum variant: <span style='color: green;'>```Samoa = 183```</span>
  Samoa = 183,
  /// C++ enum variant: <span style='color: green;'>```SanMarino = 184```</span>
  SanMarino = 184,
  /// C++ enum variant: <span style='color: green;'>```SaoTomeAndPrincipe = 185```</span>
  SaoTomeAndPrincipe = 185,
  /// C++ enum variant: <span style='color: green;'>```SaudiArabia = 186```</span>
  SaudiArabia = 186,
  /// C++ enum variant: <span style='color: green;'>```Senegal = 187```</span>
  Senegal = 187,
  /// C++ enum variant: <span style='color: green;'>```Seychelles = 188```</span>
  Seychelles = 188,
  /// C++ enum variant: <span style='color: green;'>```SierraLeone = 189```</span>
  SierraLeone = 189,
  /// C++ enum variant: <span style='color: green;'>```Singapore = 190```</span>
  Singapore = 190,
  /// C++ enum variant: <span style='color: green;'>```Slovakia = 191```</span>
  Slovakia = 191,
  /// C++ enum variant: <span style='color: green;'>```Slovenia = 192```</span>
  Slovenia = 192,
  /// C++ enum variant: <span style='color: green;'>```SolomonIslands = 193```</span>
  SolomonIslands = 193,
  /// C++ enum variant: <span style='color: green;'>```Somalia = 194```</span>
  Somalia = 194,
  /// C++ enum variant: <span style='color: green;'>```SouthAfrica = 195```</span>
  SouthAfrica = 195,
  /// C++ enum variant: <span style='color: green;'>```SouthGeorgiaAndTheSouthSandwichIslands = 196```</span>
  SouthGeorgiaAndTheSouthSandwichIslands = 196,
  /// C++ enum variant: <span style='color: green;'>```Spain = 197```</span>
  Spain = 197,
  /// C++ enum variant: <span style='color: green;'>```SriLanka = 198```</span>
  SriLanka = 198,
  /// C++ enum variant: <span style='color: green;'>```SaintHelena = 199```</span>
  SaintHelena = 199,
  /// C++ enum variant: <span style='color: green;'>```SaintPierreAndMiquelon = 200```</span>
  SaintPierreAndMiquelon = 200,
  /// C++ enum variant: <span style='color: green;'>```Sudan = 201```</span>
  Sudan = 201,
  /// C++ enum variant: <span style='color: green;'>```Suriname = 202```</span>
  Suriname = 202,
  /// C++ enum variant: <span style='color: green;'>```SvalbardAndJanMayenIslands = 203```</span>
  SvalbardAndJanMayenIslands = 203,
  /// C++ enum variant: <span style='color: green;'>```Swaziland = 204```</span>
  Swaziland = 204,
  /// C++ enum variant: <span style='color: green;'>```Sweden = 205```</span>
  Sweden = 205,
  /// C++ enum variant: <span style='color: green;'>```Switzerland = 206```</span>
  Switzerland = 206,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Syria = 207```</span>
  /// - <span style='color: green;'>```SyrianArabRepublic = 207```</span>
  ///
  Syria = 207,
  /// C++ enum variant: <span style='color: green;'>```Taiwan = 208```</span>
  Taiwan = 208,
  /// C++ enum variant: <span style='color: green;'>```Tajikistan = 209```</span>
  Tajikistan = 209,
  /// C++ enum variant: <span style='color: green;'>```Tanzania = 210```</span>
  Tanzania = 210,
  /// C++ enum variant: <span style='color: green;'>```Thailand = 211```</span>
  Thailand = 211,
  /// C++ enum variant: <span style='color: green;'>```Togo = 212```</span>
  Togo = 212,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```TokelauCountry = 213```</span>
  /// - <span style='color: green;'>```Tokelau = 213```</span>
  ///
  TokelauCountry = 213,
  /// C++ enum variant: <span style='color: green;'>```Tonga = 214```</span>
  Tonga = 214,
  /// C++ enum variant: <span style='color: green;'>```TrinidadAndTobago = 215```</span>
  TrinidadAndTobago = 215,
  /// C++ enum variant: <span style='color: green;'>```Tunisia = 216```</span>
  Tunisia = 216,
  /// C++ enum variant: <span style='color: green;'>```Turkey = 217```</span>
  Turkey = 217,
  /// C++ enum variant: <span style='color: green;'>```Turkmenistan = 218```</span>
  Turkmenistan = 218,
  /// C++ enum variant: <span style='color: green;'>```TurksAndCaicosIslands = 219```</span>
  TurksAndCaicosIslands = 219,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```TuvaluCountry = 220```</span>
  /// - <span style='color: green;'>```Tuvalu = 220```</span>
  ///
  TuvaluCountry = 220,
  /// C++ enum variant: <span style='color: green;'>```Uganda = 221```</span>
  Uganda = 221,
  /// C++ enum variant: <span style='color: green;'>```Ukraine = 222```</span>
  Ukraine = 222,
  /// C++ enum variant: <span style='color: green;'>```UnitedArabEmirates = 223```</span>
  UnitedArabEmirates = 223,
  /// C++ enum variant: <span style='color: green;'>```UnitedKingdom = 224```</span>
  UnitedKingdom = 224,
  /// C++ enum variant: <span style='color: green;'>```UnitedStates = 225```</span>
  UnitedStates = 225,
  /// C++ enum variant: <span style='color: green;'>```UnitedStatesMinorOutlyingIslands = 226```</span>
  UnitedStatesMinorOutlyingIslands = 226,
  /// C++ enum variant: <span style='color: green;'>```Uruguay = 227```</span>
  Uruguay = 227,
  /// C++ enum variant: <span style='color: green;'>```Uzbekistan = 228```</span>
  Uzbekistan = 228,
  /// C++ enum variant: <span style='color: green;'>```Vanuatu = 229```</span>
  Vanuatu = 229,
  /// C++ enum variant: <span style='color: green;'>```VaticanCityState = 230```</span>
  VaticanCityState = 230,
  /// C++ enum variant: <span style='color: green;'>```Venezuela = 231```</span>
  Venezuela = 231,
  /// C++ enum variant: <span style='color: green;'>```Vietnam = 232```</span>
  Vietnam = 232,
  /// C++ enum variant: <span style='color: green;'>```BritishVirginIslands = 233```</span>
  BritishVirginIslands = 233,
  /// C++ enum variant: <span style='color: green;'>```UnitedStatesVirginIslands = 234```</span>
  UnitedStatesVirginIslands = 234,
  /// C++ enum variant: <span style='color: green;'>```WallisAndFutunaIslands = 235```</span>
  WallisAndFutunaIslands = 235,
  /// C++ enum variant: <span style='color: green;'>```WesternSahara = 236```</span>
  WesternSahara = 236,
  /// C++ enum variant: <span style='color: green;'>```Yemen = 237```</span>
  Yemen = 237,
  /// C++ enum variant: <span style='color: green;'>```CanaryIslands = 238```</span>
  CanaryIslands = 238,
  /// C++ enum variant: <span style='color: green;'>```Zambia = 239```</span>
  Zambia = 239,
  /// C++ enum variant: <span style='color: green;'>```Zimbabwe = 240```</span>
  Zimbabwe = 240,
  /// C++ enum variant: <span style='color: green;'>```ClippertonIsland = 241```</span>
  ClippertonIsland = 241,
  /// C++ enum variant: <span style='color: green;'>```Montenegro = 242```</span>
  Montenegro = 242,
  /// C++ enum variant: <span style='color: green;'>```Serbia = 243```</span>
  Serbia = 243,
  /// C++ enum variant: <span style='color: green;'>```SaintBarthelemy = 244```</span>
  SaintBarthelemy = 244,
  /// C++ enum variant: <span style='color: green;'>```SaintMartin = 245```</span>
  SaintMartin = 245,
  /// C++ enum variant: <span style='color: green;'>```LatinAmericaAndTheCaribbean = 246```</span>
  LatinAmericaAndTheCaribbean = 246,
  /// C++ enum variant: <span style='color: green;'>```AscensionIsland = 247```</span>
  AscensionIsland = 247,
  /// C++ enum variant: <span style='color: green;'>```AlandIslands = 248```</span>
  AlandIslands = 248,
  /// C++ enum variant: <span style='color: green;'>```DiegoGarcia = 249```</span>
  DiegoGarcia = 249,
  /// C++ enum variant: <span style='color: green;'>```CeutaAndMelilla = 250```</span>
  CeutaAndMelilla = 250,
  /// C++ enum variant: <span style='color: green;'>```IsleOfMan = 251```</span>
  IsleOfMan = 251,
  /// C++ enum variant: <span style='color: green;'>```Jersey = 252```</span>
  Jersey = 252,
  /// C++ enum variant: <span style='color: green;'>```TristanDaCunha = 253```</span>
  TristanDaCunha = 253,
  /// C++ enum variant: <span style='color: green;'>```SouthSudan = 254```</span>
  SouthSudan = 254,
  /// C++ enum variant: <span style='color: green;'>```Bonaire = 255```</span>
  Bonaire = 255,
  /// C++ enum variant: <span style='color: green;'>```SintMaarten = 256```</span>
  SintMaarten = 256,
  /// C++ enum variant: <span style='color: green;'>```Kosovo = 257```</span>
  Kosovo = 257,
  /// C++ enum variant: <span style='color: green;'>```EuropeanUnion = 258```</span>
  EuropeanUnion = 258,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```OutlyingOceania = 259```</span>
  /// - <span style='color: green;'>```LastCountry = 259```</span>
  ///
  OutlyingOceania = 259,
}

/// C++ type: <span style='color: green;'>```QLocale::CurrencySymbolFormat```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum CurrencySymbolFormat {
  /// C++ enum variant: <span style='color: green;'>```CurrencyIsoCode = 0```</span>
  IsoCode = 0,
  /// C++ enum variant: <span style='color: green;'>```CurrencySymbol = 1```</span>
  Symbol = 1,
  /// C++ enum variant: <span style='color: green;'>```CurrencyDisplayName = 2```</span>
  DisplayName = 2,
}

/// C++ type: <span style='color: green;'>```QLocale::FloatingPointPrecisionOption```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum FloatingPointPrecisionOption {
  /// C++ enum variant: <span style='color: green;'>```FloatingPointShortest = -128```</span>
  FloatingPointShortest = -128,
  /// This variant is added in Rust because enums with one variant and C representation are not supported.
  _Invalid = 0,
}

/// C++ type: <span style='color: green;'>```QLocale::FormatType```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum FormatType {
  /// C++ enum variant: <span style='color: green;'>```LongFormat = 0```</span>
  Long = 0,
  /// C++ enum variant: <span style='color: green;'>```ShortFormat = 1```</span>
  Short = 1,
  /// C++ enum variant: <span style='color: green;'>```NarrowFormat = 2```</span>
  Narrow = 2,
}

/// C++ type: <span style='color: green;'>```QLocale::Language```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum Language {
  /// C++ enum variant: <span style='color: green;'>```AnyLanguage = 0```</span>
  AnyLanguage = 0,
  /// C++ enum variant: <span style='color: green;'>```C = 1```</span>
  C = 1,
  /// C++ enum variant: <span style='color: green;'>```Abkhazian = 2```</span>
  Abkhazian = 2,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Oromo = 3```</span>
  /// - <span style='color: green;'>```Afan = 3```</span>
  ///
  Oromo = 3,
  /// C++ enum variant: <span style='color: green;'>```Afar = 4```</span>
  Afar = 4,
  /// C++ enum variant: <span style='color: green;'>```Afrikaans = 5```</span>
  Afrikaans = 5,
  /// C++ enum variant: <span style='color: green;'>```Albanian = 6```</span>
  Albanian = 6,
  /// C++ enum variant: <span style='color: green;'>```Amharic = 7```</span>
  Amharic = 7,
  /// C++ enum variant: <span style='color: green;'>```Arabic = 8```</span>
  Arabic = 8,
  /// C++ enum variant: <span style='color: green;'>```Armenian = 9```</span>
  Armenian = 9,
  /// C++ enum variant: <span style='color: green;'>```Assamese = 10```</span>
  Assamese = 10,
  /// C++ enum variant: <span style='color: green;'>```Aymara = 11```</span>
  Aymara = 11,
  /// C++ enum variant: <span style='color: green;'>```Azerbaijani = 12```</span>
  Azerbaijani = 12,
  /// C++ enum variant: <span style='color: green;'>```Bashkir = 13```</span>
  Bashkir = 13,
  /// C++ enum variant: <span style='color: green;'>```Basque = 14```</span>
  Basque = 14,
  /// C++ enum variant: <span style='color: green;'>```Bengali = 15```</span>
  Bengali = 15,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Dzongkha = 16```</span>
  /// - <span style='color: green;'>```Bhutani = 16```</span>
  ///
  Dzongkha = 16,
  /// C++ enum variant: <span style='color: green;'>```Bihari = 17```</span>
  Bihari = 17,
  /// C++ enum variant: <span style='color: green;'>```Bislama = 18```</span>
  Bislama = 18,
  /// C++ enum variant: <span style='color: green;'>```Breton = 19```</span>
  Breton = 19,
  /// C++ enum variant: <span style='color: green;'>```Bulgarian = 20```</span>
  Bulgarian = 20,
  /// C++ enum variant: <span style='color: green;'>```Burmese = 21```</span>
  Burmese = 21,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Belarusian = 22```</span>
  /// - <span style='color: green;'>```Byelorussian = 22```</span>
  ///
  Belarusian = 22,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Khmer = 23```</span>
  /// - <span style='color: green;'>```Cambodian = 23```</span>
  ///
  Khmer = 23,
  /// C++ enum variant: <span style='color: green;'>```Catalan = 24```</span>
  Catalan = 24,
  /// C++ enum variant: <span style='color: green;'>```Chinese = 25```</span>
  Chinese = 25,
  /// C++ enum variant: <span style='color: green;'>```Corsican = 26```</span>
  Corsican = 26,
  /// C++ enum variant: <span style='color: green;'>```Croatian = 27```</span>
  Croatian = 27,
  /// C++ enum variant: <span style='color: green;'>```Czech = 28```</span>
  Czech = 28,
  /// C++ enum variant: <span style='color: green;'>```Danish = 29```</span>
  Danish = 29,
  /// C++ enum variant: <span style='color: green;'>```Dutch = 30```</span>
  Dutch = 30,
  /// C++ enum variant: <span style='color: green;'>```English = 31```</span>
  English = 31,
  /// C++ enum variant: <span style='color: green;'>```Esperanto = 32```</span>
  Esperanto = 32,
  /// C++ enum variant: <span style='color: green;'>```Estonian = 33```</span>
  Estonian = 33,
  /// C++ enum variant: <span style='color: green;'>```Faroese = 34```</span>
  Faroese = 34,
  /// C++ enum variant: <span style='color: green;'>```Fijian = 35```</span>
  Fijian = 35,
  /// C++ enum variant: <span style='color: green;'>```Finnish = 36```</span>
  Finnish = 36,
  /// C++ enum variant: <span style='color: green;'>```French = 37```</span>
  French = 37,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```WesternFrisian = 38```</span>
  /// - <span style='color: green;'>```Frisian = 38```</span>
  ///
  WesternFrisian = 38,
  /// C++ enum variant: <span style='color: green;'>```Gaelic = 39```</span>
  Gaelic = 39,
  /// C++ enum variant: <span style='color: green;'>```Galician = 40```</span>
  Galician = 40,
  /// C++ enum variant: <span style='color: green;'>```Georgian = 41```</span>
  Georgian = 41,
  /// C++ enum variant: <span style='color: green;'>```German = 42```</span>
  German = 42,
  /// C++ enum variant: <span style='color: green;'>```Greek = 43```</span>
  Greek = 43,
  /// C++ enum variant: <span style='color: green;'>```Greenlandic = 44```</span>
  Greenlandic = 44,
  /// C++ enum variant: <span style='color: green;'>```Guarani = 45```</span>
  Guarani = 45,
  /// C++ enum variant: <span style='color: green;'>```Gujarati = 46```</span>
  Gujarati = 46,
  /// C++ enum variant: <span style='color: green;'>```Hausa = 47```</span>
  Hausa = 47,
  /// C++ enum variant: <span style='color: green;'>```Hebrew = 48```</span>
  Hebrew = 48,
  /// C++ enum variant: <span style='color: green;'>```Hindi = 49```</span>
  Hindi = 49,
  /// C++ enum variant: <span style='color: green;'>```Hungarian = 50```</span>
  Hungarian = 50,
  /// C++ enum variant: <span style='color: green;'>```Icelandic = 51```</span>
  Icelandic = 51,
  /// C++ enum variant: <span style='color: green;'>```Indonesian = 52```</span>
  Indonesian = 52,
  /// C++ enum variant: <span style='color: green;'>```Interlingua = 53```</span>
  Interlingua = 53,
  /// C++ enum variant: <span style='color: green;'>```Interlingue = 54```</span>
  Interlingue = 54,
  /// C++ enum variant: <span style='color: green;'>```Inuktitut = 55```</span>
  Inuktitut = 55,
  /// C++ enum variant: <span style='color: green;'>```Inupiak = 56```</span>
  Inupiak = 56,
  /// C++ enum variant: <span style='color: green;'>```Irish = 57```</span>
  Irish = 57,
  /// C++ enum variant: <span style='color: green;'>```Italian = 58```</span>
  Italian = 58,
  /// C++ enum variant: <span style='color: green;'>```Japanese = 59```</span>
  Japanese = 59,
  /// C++ enum variant: <span style='color: green;'>```Javanese = 60```</span>
  Javanese = 60,
  /// C++ enum variant: <span style='color: green;'>```Kannada = 61```</span>
  Kannada = 61,
  /// C++ enum variant: <span style='color: green;'>```Kashmiri = 62```</span>
  Kashmiri = 62,
  /// C++ enum variant: <span style='color: green;'>```Kazakh = 63```</span>
  Kazakh = 63,
  /// C++ enum variant: <span style='color: green;'>```Kinyarwanda = 64```</span>
  Kinyarwanda = 64,
  /// C++ enum variant: <span style='color: green;'>```Kirghiz = 65```</span>
  Kirghiz = 65,
  /// C++ enum variant: <span style='color: green;'>```Korean = 66```</span>
  Korean = 66,
  /// C++ enum variant: <span style='color: green;'>```Kurdish = 67```</span>
  Kurdish = 67,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Rundi = 68```</span>
  /// - <span style='color: green;'>```Kurundi = 68```</span>
  ///
  Rundi = 68,
  /// C++ enum variant: <span style='color: green;'>```Lao = 69```</span>
  Lao = 69,
  /// C++ enum variant: <span style='color: green;'>```Latin = 70```</span>
  Latin = 70,
  /// C++ enum variant: <span style='color: green;'>```Latvian = 71```</span>
  Latvian = 71,
  /// C++ enum variant: <span style='color: green;'>```Lingala = 72```</span>
  Lingala = 72,
  /// C++ enum variant: <span style='color: green;'>```Lithuanian = 73```</span>
  Lithuanian = 73,
  /// C++ enum variant: <span style='color: green;'>```Macedonian = 74```</span>
  Macedonian = 74,
  /// C++ enum variant: <span style='color: green;'>```Malagasy = 75```</span>
  Malagasy = 75,
  /// C++ enum variant: <span style='color: green;'>```Malay = 76```</span>
  Malay = 76,
  /// C++ enum variant: <span style='color: green;'>```Malayalam = 77```</span>
  Malayalam = 77,
  /// C++ enum variant: <span style='color: green;'>```Maltese = 78```</span>
  Maltese = 78,
  /// C++ enum variant: <span style='color: green;'>```Maori = 79```</span>
  Maori = 79,
  /// C++ enum variant: <span style='color: green;'>```Marathi = 80```</span>
  Marathi = 80,
  /// C++ enum variant: <span style='color: green;'>```Marshallese = 81```</span>
  Marshallese = 81,
  /// C++ enum variant: <span style='color: green;'>```Mongolian = 82```</span>
  Mongolian = 82,
  /// C++ enum variant: <span style='color: green;'>```NauruLanguage = 83```</span>
  NauruLanguage = 83,
  /// C++ enum variant: <span style='color: green;'>```Nepali = 84```</span>
  Nepali = 84,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```NorwegianBokmal = 85```</span>
  /// - <span style='color: green;'>```Norwegian = 85```</span>
  ///
  NorwegianBokmal = 85,
  /// C++ enum variant: <span style='color: green;'>```Occitan = 86```</span>
  Occitan = 86,
  /// C++ enum variant: <span style='color: green;'>```Oriya = 87```</span>
  Oriya = 87,
  /// C++ enum variant: <span style='color: green;'>```Pashto = 88```</span>
  Pashto = 88,
  /// C++ enum variant: <span style='color: green;'>```Persian = 89```</span>
  Persian = 89,
  /// C++ enum variant: <span style='color: green;'>```Polish = 90```</span>
  Polish = 90,
  /// C++ enum variant: <span style='color: green;'>```Portuguese = 91```</span>
  Portuguese = 91,
  /// C++ enum variant: <span style='color: green;'>```Punjabi = 92```</span>
  Punjabi = 92,
  /// C++ enum variant: <span style='color: green;'>```Quechua = 93```</span>
  Quechua = 93,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Romansh = 94```</span>
  /// - <span style='color: green;'>```RhaetoRomance = 94```</span>
  ///
  Romansh = 94,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Romanian = 95```</span>
  /// - <span style='color: green;'>```Moldavian = 95```</span>
  ///
  Romanian = 95,
  /// C++ enum variant: <span style='color: green;'>```Russian = 96```</span>
  Russian = 96,
  /// C++ enum variant: <span style='color: green;'>```Samoan = 97```</span>
  Samoan = 97,
  /// C++ enum variant: <span style='color: green;'>```Sango = 98```</span>
  Sango = 98,
  /// C++ enum variant: <span style='color: green;'>```Sanskrit = 99```</span>
  Sanskrit = 99,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Serbian = 100```</span>
  /// - <span style='color: green;'>```SerboCroatian = 100```</span>
  ///
  Serbian = 100,
  /// C++ enum variant: <span style='color: green;'>```Ossetic = 101```</span>
  Ossetic = 101,
  /// C++ enum variant: <span style='color: green;'>```SouthernSotho = 102```</span>
  SouthernSotho = 102,
  /// C++ enum variant: <span style='color: green;'>```Tswana = 103```</span>
  Tswana = 103,
  /// C++ enum variant: <span style='color: green;'>```Shona = 104```</span>
  Shona = 104,
  /// C++ enum variant: <span style='color: green;'>```Sindhi = 105```</span>
  Sindhi = 105,
  /// C++ enum variant: <span style='color: green;'>```Sinhala = 106```</span>
  Sinhala = 106,
  /// C++ enum variant: <span style='color: green;'>```Swati = 107```</span>
  Swati = 107,
  /// C++ enum variant: <span style='color: green;'>```Slovak = 108```</span>
  Slovak = 108,
  /// C++ enum variant: <span style='color: green;'>```Slovenian = 109```</span>
  Slovenian = 109,
  /// C++ enum variant: <span style='color: green;'>```Somali = 110```</span>
  Somali = 110,
  /// C++ enum variant: <span style='color: green;'>```Spanish = 111```</span>
  Spanish = 111,
  /// C++ enum variant: <span style='color: green;'>```Sundanese = 112```</span>
  Sundanese = 112,
  /// C++ enum variant: <span style='color: green;'>```Swahili = 113```</span>
  Swahili = 113,
  /// C++ enum variant: <span style='color: green;'>```Swedish = 114```</span>
  Swedish = 114,
  /// C++ enum variant: <span style='color: green;'>```Sardinian = 115```</span>
  Sardinian = 115,
  /// C++ enum variant: <span style='color: green;'>```Tajik = 116```</span>
  Tajik = 116,
  /// C++ enum variant: <span style='color: green;'>```Tamil = 117```</span>
  Tamil = 117,
  /// C++ enum variant: <span style='color: green;'>```Tatar = 118```</span>
  Tatar = 118,
  /// C++ enum variant: <span style='color: green;'>```Telugu = 119```</span>
  Telugu = 119,
  /// C++ enum variant: <span style='color: green;'>```Thai = 120```</span>
  Thai = 120,
  /// C++ enum variant: <span style='color: green;'>```Tibetan = 121```</span>
  Tibetan = 121,
  /// C++ enum variant: <span style='color: green;'>```Tigrinya = 122```</span>
  Tigrinya = 122,
  /// C++ enum variant: <span style='color: green;'>```Tongan = 123```</span>
  Tongan = 123,
  /// C++ enum variant: <span style='color: green;'>```Tsonga = 124```</span>
  Tsonga = 124,
  /// C++ enum variant: <span style='color: green;'>```Turkish = 125```</span>
  Turkish = 125,
  /// C++ enum variant: <span style='color: green;'>```Turkmen = 126```</span>
  Turkmen = 126,
  /// C++ enum variant: <span style='color: green;'>```Tahitian = 127```</span>
  Tahitian = 127,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Uighur = 128```</span>
  /// - <span style='color: green;'>```Uigur = 128```</span>
  ///
  Uighur = 128,
  /// C++ enum variant: <span style='color: green;'>```Ukrainian = 129```</span>
  Ukrainian = 129,
  /// C++ enum variant: <span style='color: green;'>```Urdu = 130```</span>
  Urdu = 130,
  /// C++ enum variant: <span style='color: green;'>```Uzbek = 131```</span>
  Uzbek = 131,
  /// C++ enum variant: <span style='color: green;'>```Vietnamese = 132```</span>
  Vietnamese = 132,
  /// C++ enum variant: <span style='color: green;'>```Volapuk = 133```</span>
  Volapuk = 133,
  /// C++ enum variant: <span style='color: green;'>```Welsh = 134```</span>
  Welsh = 134,
  /// C++ enum variant: <span style='color: green;'>```Wolof = 135```</span>
  Wolof = 135,
  /// C++ enum variant: <span style='color: green;'>```Xhosa = 136```</span>
  Xhosa = 136,
  /// C++ enum variant: <span style='color: green;'>```Yiddish = 137```</span>
  Yiddish = 137,
  /// C++ enum variant: <span style='color: green;'>```Yoruba = 138```</span>
  Yoruba = 138,
  /// C++ enum variant: <span style='color: green;'>```Zhuang = 139```</span>
  Zhuang = 139,
  /// C++ enum variant: <span style='color: green;'>```Zulu = 140```</span>
  Zulu = 140,
  /// C++ enum variant: <span style='color: green;'>```NorwegianNynorsk = 141```</span>
  NorwegianNynorsk = 141,
  /// C++ enum variant: <span style='color: green;'>```Bosnian = 142```</span>
  Bosnian = 142,
  /// C++ enum variant: <span style='color: green;'>```Divehi = 143```</span>
  Divehi = 143,
  /// C++ enum variant: <span style='color: green;'>```Manx = 144```</span>
  Manx = 144,
  /// C++ enum variant: <span style='color: green;'>```Cornish = 145```</span>
  Cornish = 145,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Akan = 146```</span>
  /// - <span style='color: green;'>```Twi = 146```</span>
  ///
  Akan = 146,
  /// C++ enum variant: <span style='color: green;'>```Konkani = 147```</span>
  Konkani = 147,
  /// C++ enum variant: <span style='color: green;'>```Ga = 148```</span>
  Ga = 148,
  /// C++ enum variant: <span style='color: green;'>```Igbo = 149```</span>
  Igbo = 149,
  /// C++ enum variant: <span style='color: green;'>```Kamba = 150```</span>
  Kamba = 150,
  /// C++ enum variant: <span style='color: green;'>```Syriac = 151```</span>
  Syriac = 151,
  /// C++ enum variant: <span style='color: green;'>```Blin = 152```</span>
  Blin = 152,
  /// C++ enum variant: <span style='color: green;'>```Geez = 153```</span>
  Geez = 153,
  /// C++ enum variant: <span style='color: green;'>```Koro = 154```</span>
  Koro = 154,
  /// C++ enum variant: <span style='color: green;'>```Sidamo = 155```</span>
  Sidamo = 155,
  /// C++ enum variant: <span style='color: green;'>```Atsam = 156```</span>
  Atsam = 156,
  /// C++ enum variant: <span style='color: green;'>```Tigre = 157```</span>
  Tigre = 157,
  /// C++ enum variant: <span style='color: green;'>```Jju = 158```</span>
  Jju = 158,
  /// C++ enum variant: <span style='color: green;'>```Friulian = 159```</span>
  Friulian = 159,
  /// C++ enum variant: <span style='color: green;'>```Venda = 160```</span>
  Venda = 160,
  /// C++ enum variant: <span style='color: green;'>```Ewe = 161```</span>
  Ewe = 161,
  /// C++ enum variant: <span style='color: green;'>```Walamo = 162```</span>
  Walamo = 162,
  /// C++ enum variant: <span style='color: green;'>```Hawaiian = 163```</span>
  Hawaiian = 163,
  /// C++ enum variant: <span style='color: green;'>```Tyap = 164```</span>
  Tyap = 164,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Nyanja = 165```</span>
  /// - <span style='color: green;'>```Chewa = 165```</span>
  ///
  Nyanja = 165,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Filipino = 166```</span>
  /// - <span style='color: green;'>```Tagalog = 166```</span>
  ///
  Filipino = 166,
  /// C++ enum variant: <span style='color: green;'>```SwissGerman = 167```</span>
  SwissGerman = 167,
  /// C++ enum variant: <span style='color: green;'>```SichuanYi = 168```</span>
  SichuanYi = 168,
  /// C++ enum variant: <span style='color: green;'>```Kpelle = 169```</span>
  Kpelle = 169,
  /// C++ enum variant: <span style='color: green;'>```LowGerman = 170```</span>
  LowGerman = 170,
  /// C++ enum variant: <span style='color: green;'>```SouthNdebele = 171```</span>
  SouthNdebele = 171,
  /// C++ enum variant: <span style='color: green;'>```NorthernSotho = 172```</span>
  NorthernSotho = 172,
  /// C++ enum variant: <span style='color: green;'>```NorthernSami = 173```</span>
  NorthernSami = 173,
  /// C++ enum variant: <span style='color: green;'>```Taroko = 174```</span>
  Taroko = 174,
  /// C++ enum variant: <span style='color: green;'>```Gusii = 175```</span>
  Gusii = 175,
  /// C++ enum variant: <span style='color: green;'>```Taita = 176```</span>
  Taita = 176,
  /// C++ enum variant: <span style='color: green;'>```Fulah = 177```</span>
  Fulah = 177,
  /// C++ enum variant: <span style='color: green;'>```Kikuyu = 178```</span>
  Kikuyu = 178,
  /// C++ enum variant: <span style='color: green;'>```Samburu = 179```</span>
  Samburu = 179,
  /// C++ enum variant: <span style='color: green;'>```Sena = 180```</span>
  Sena = 180,
  /// C++ enum variant: <span style='color: green;'>```NorthNdebele = 181```</span>
  NorthNdebele = 181,
  /// C++ enum variant: <span style='color: green;'>```Rombo = 182```</span>
  Rombo = 182,
  /// C++ enum variant: <span style='color: green;'>```Tachelhit = 183```</span>
  Tachelhit = 183,
  /// C++ enum variant: <span style='color: green;'>```Kabyle = 184```</span>
  Kabyle = 184,
  /// C++ enum variant: <span style='color: green;'>```Nyankole = 185```</span>
  Nyankole = 185,
  /// C++ enum variant: <span style='color: green;'>```Bena = 186```</span>
  Bena = 186,
  /// C++ enum variant: <span style='color: green;'>```Vunjo = 187```</span>
  Vunjo = 187,
  /// C++ enum variant: <span style='color: green;'>```Bambara = 188```</span>
  Bambara = 188,
  /// C++ enum variant: <span style='color: green;'>```Embu = 189```</span>
  Embu = 189,
  /// C++ enum variant: <span style='color: green;'>```Cherokee = 190```</span>
  Cherokee = 190,
  /// C++ enum variant: <span style='color: green;'>```Morisyen = 191```</span>
  Morisyen = 191,
  /// C++ enum variant: <span style='color: green;'>```Makonde = 192```</span>
  Makonde = 192,
  /// C++ enum variant: <span style='color: green;'>```Langi = 193```</span>
  Langi = 193,
  /// C++ enum variant: <span style='color: green;'>```Ganda = 194```</span>
  Ganda = 194,
  /// C++ enum variant: <span style='color: green;'>```Bemba = 195```</span>
  Bemba = 195,
  /// C++ enum variant: <span style='color: green;'>```Kabuverdianu = 196```</span>
  Kabuverdianu = 196,
  /// C++ enum variant: <span style='color: green;'>```Meru = 197```</span>
  Meru = 197,
  /// C++ enum variant: <span style='color: green;'>```Kalenjin = 198```</span>
  Kalenjin = 198,
  /// C++ enum variant: <span style='color: green;'>```Nama = 199```</span>
  Nama = 199,
  /// C++ enum variant: <span style='color: green;'>```Machame = 200```</span>
  Machame = 200,
  /// C++ enum variant: <span style='color: green;'>```Colognian = 201```</span>
  Colognian = 201,
  /// C++ enum variant: <span style='color: green;'>```Masai = 202```</span>
  Masai = 202,
  /// C++ enum variant: <span style='color: green;'>```Soga = 203```</span>
  Soga = 203,
  /// C++ enum variant: <span style='color: green;'>```Luyia = 204```</span>
  Luyia = 204,
  /// C++ enum variant: <span style='color: green;'>```Asu = 205```</span>
  Asu = 205,
  /// C++ enum variant: <span style='color: green;'>```Teso = 206```</span>
  Teso = 206,
  /// C++ enum variant: <span style='color: green;'>```Saho = 207```</span>
  Saho = 207,
  /// C++ enum variant: <span style='color: green;'>```KoyraChiini = 208```</span>
  KoyraChiini = 208,
  /// C++ enum variant: <span style='color: green;'>```Rwa = 209```</span>
  Rwa = 209,
  /// C++ enum variant: <span style='color: green;'>```Luo = 210```</span>
  Luo = 210,
  /// C++ enum variant: <span style='color: green;'>```Chiga = 211```</span>
  Chiga = 211,
  /// C++ enum variant: <span style='color: green;'>```CentralMoroccoTamazight = 212```</span>
  CentralMoroccoTamazight = 212,
  /// C++ enum variant: <span style='color: green;'>```KoyraboroSenni = 213```</span>
  KoyraboroSenni = 213,
  /// C++ enum variant: <span style='color: green;'>```Shambala = 214```</span>
  Shambala = 214,
  /// C++ enum variant: <span style='color: green;'>```Bodo = 215```</span>
  Bodo = 215,
  /// C++ enum variant: <span style='color: green;'>```Avaric = 216```</span>
  Avaric = 216,
  /// C++ enum variant: <span style='color: green;'>```Chamorro = 217```</span>
  Chamorro = 217,
  /// C++ enum variant: <span style='color: green;'>```Chechen = 218```</span>
  Chechen = 218,
  /// C++ enum variant: <span style='color: green;'>```Church = 219```</span>
  Church = 219,
  /// C++ enum variant: <span style='color: green;'>```Chuvash = 220```</span>
  Chuvash = 220,
  /// C++ enum variant: <span style='color: green;'>```Cree = 221```</span>
  Cree = 221,
  /// C++ enum variant: <span style='color: green;'>```Haitian = 222```</span>
  Haitian = 222,
  /// C++ enum variant: <span style='color: green;'>```Herero = 223```</span>
  Herero = 223,
  /// C++ enum variant: <span style='color: green;'>```HiriMotu = 224```</span>
  HiriMotu = 224,
  /// C++ enum variant: <span style='color: green;'>```Kanuri = 225```</span>
  Kanuri = 225,
  /// C++ enum variant: <span style='color: green;'>```Komi = 226```</span>
  Komi = 226,
  /// C++ enum variant: <span style='color: green;'>```Kongo = 227```</span>
  Kongo = 227,
  /// C++ enum variant: <span style='color: green;'>```Kwanyama = 228```</span>
  Kwanyama = 228,
  /// C++ enum variant: <span style='color: green;'>```Limburgish = 229```</span>
  Limburgish = 229,
  /// C++ enum variant: <span style='color: green;'>```LubaKatanga = 230```</span>
  LubaKatanga = 230,
  /// C++ enum variant: <span style='color: green;'>```Luxembourgish = 231```</span>
  Luxembourgish = 231,
  /// C++ enum variant: <span style='color: green;'>```Navaho = 232```</span>
  Navaho = 232,
  /// C++ enum variant: <span style='color: green;'>```Ndonga = 233```</span>
  Ndonga = 233,
  /// C++ enum variant: <span style='color: green;'>```Ojibwa = 234```</span>
  Ojibwa = 234,
  /// C++ enum variant: <span style='color: green;'>```Pali = 235```</span>
  Pali = 235,
  /// C++ enum variant: <span style='color: green;'>```Walloon = 236```</span>
  Walloon = 236,
  /// C++ enum variant: <span style='color: green;'>```Aghem = 237```</span>
  Aghem = 237,
  /// C++ enum variant: <span style='color: green;'>```Basaa = 238```</span>
  Basaa = 238,
  /// C++ enum variant: <span style='color: green;'>```Zarma = 239```</span>
  Zarma = 239,
  /// C++ enum variant: <span style='color: green;'>```Duala = 240```</span>
  Duala = 240,
  /// C++ enum variant: <span style='color: green;'>```JolaFonyi = 241```</span>
  JolaFonyi = 241,
  /// C++ enum variant: <span style='color: green;'>```Ewondo = 242```</span>
  Ewondo = 242,
  /// C++ enum variant: <span style='color: green;'>```Bafia = 243```</span>
  Bafia = 243,
  /// C++ enum variant: <span style='color: green;'>```MakhuwaMeetto = 244```</span>
  MakhuwaMeetto = 244,
  /// C++ enum variant: <span style='color: green;'>```Mundang = 245```</span>
  Mundang = 245,
  /// C++ enum variant: <span style='color: green;'>```Kwasio = 246```</span>
  Kwasio = 246,
  /// C++ enum variant: <span style='color: green;'>```Nuer = 247```</span>
  Nuer = 247,
  /// C++ enum variant: <span style='color: green;'>```Sakha = 248```</span>
  Sakha = 248,
  /// C++ enum variant: <span style='color: green;'>```Sangu = 249```</span>
  Sangu = 249,
  /// C++ enum variant: <span style='color: green;'>```CongoSwahili = 250```</span>
  CongoSwahili = 250,
  /// C++ enum variant: <span style='color: green;'>```Tasawaq = 251```</span>
  Tasawaq = 251,
  /// C++ enum variant: <span style='color: green;'>```Vai = 252```</span>
  Vai = 252,
  /// C++ enum variant: <span style='color: green;'>```Walser = 253```</span>
  Walser = 253,
  /// C++ enum variant: <span style='color: green;'>```Yangben = 254```</span>
  Yangben = 254,
  /// C++ enum variant: <span style='color: green;'>```Avestan = 255```</span>
  Avestan = 255,
  /// C++ enum variant: <span style='color: green;'>```Asturian = 256```</span>
  Asturian = 256,
  /// C++ enum variant: <span style='color: green;'>```Ngomba = 257```</span>
  Ngomba = 257,
  /// C++ enum variant: <span style='color: green;'>```Kako = 258```</span>
  Kako = 258,
  /// C++ enum variant: <span style='color: green;'>```Meta = 259```</span>
  Meta = 259,
  /// C++ enum variant: <span style='color: green;'>```Ngiemboon = 260```</span>
  Ngiemboon = 260,
  /// C++ enum variant: <span style='color: green;'>```Aragonese = 261```</span>
  Aragonese = 261,
  /// C++ enum variant: <span style='color: green;'>```Akkadian = 262```</span>
  Akkadian = 262,
  /// C++ enum variant: <span style='color: green;'>```AncientEgyptian = 263```</span>
  AncientEgyptian = 263,
  /// C++ enum variant: <span style='color: green;'>```AncientGreek = 264```</span>
  AncientGreek = 264,
  /// C++ enum variant: <span style='color: green;'>```Aramaic = 265```</span>
  Aramaic = 265,
  /// C++ enum variant: <span style='color: green;'>```Balinese = 266```</span>
  Balinese = 266,
  /// C++ enum variant: <span style='color: green;'>```Bamun = 267```</span>
  Bamun = 267,
  /// C++ enum variant: <span style='color: green;'>```BatakToba = 268```</span>
  BatakToba = 268,
  /// C++ enum variant: <span style='color: green;'>```Buginese = 269```</span>
  Buginese = 269,
  /// C++ enum variant: <span style='color: green;'>```Buhid = 270```</span>
  Buhid = 270,
  /// C++ enum variant: <span style='color: green;'>```Carian = 271```</span>
  Carian = 271,
  /// C++ enum variant: <span style='color: green;'>```Chakma = 272```</span>
  Chakma = 272,
  /// C++ enum variant: <span style='color: green;'>```ClassicalMandaic = 273```</span>
  ClassicalMandaic = 273,
  /// C++ enum variant: <span style='color: green;'>```Coptic = 274```</span>
  Coptic = 274,
  /// C++ enum variant: <span style='color: green;'>```Dogri = 275```</span>
  Dogri = 275,
  /// C++ enum variant: <span style='color: green;'>```EasternCham = 276```</span>
  EasternCham = 276,
  /// C++ enum variant: <span style='color: green;'>```EasternKayah = 277```</span>
  EasternKayah = 277,
  /// C++ enum variant: <span style='color: green;'>```Etruscan = 278```</span>
  Etruscan = 278,
  /// C++ enum variant: <span style='color: green;'>```Gothic = 279```</span>
  Gothic = 279,
  /// C++ enum variant: <span style='color: green;'>```Hanunoo = 280```</span>
  Hanunoo = 280,
  /// C++ enum variant: <span style='color: green;'>```Ingush = 281```</span>
  Ingush = 281,
  /// C++ enum variant: <span style='color: green;'>```LargeFloweryMiao = 282```</span>
  LargeFloweryMiao = 282,
  /// C++ enum variant: <span style='color: green;'>```Lepcha = 283```</span>
  Lepcha = 283,
  /// C++ enum variant: <span style='color: green;'>```Limbu = 284```</span>
  Limbu = 284,
  /// C++ enum variant: <span style='color: green;'>```Lisu = 285```</span>
  Lisu = 285,
  /// C++ enum variant: <span style='color: green;'>```Lu = 286```</span>
  Lu = 286,
  /// C++ enum variant: <span style='color: green;'>```Lycian = 287```</span>
  Lycian = 287,
  /// C++ enum variant: <span style='color: green;'>```Lydian = 288```</span>
  Lydian = 288,
  /// C++ enum variant: <span style='color: green;'>```Mandingo = 289```</span>
  Mandingo = 289,
  /// C++ enum variant: <span style='color: green;'>```Manipuri = 290```</span>
  Manipuri = 290,
  /// C++ enum variant: <span style='color: green;'>```Meroitic = 291```</span>
  Meroitic = 291,
  /// C++ enum variant: <span style='color: green;'>```NorthernThai = 292```</span>
  NorthernThai = 292,
  /// C++ enum variant: <span style='color: green;'>```OldIrish = 293```</span>
  OldIrish = 293,
  /// C++ enum variant: <span style='color: green;'>```OldNorse = 294```</span>
  OldNorse = 294,
  /// C++ enum variant: <span style='color: green;'>```OldPersian = 295```</span>
  OldPersian = 295,
  /// C++ enum variant: <span style='color: green;'>```OldTurkish = 296```</span>
  OldTurkish = 296,
  /// C++ enum variant: <span style='color: green;'>```Pahlavi = 297```</span>
  Pahlavi = 297,
  /// C++ enum variant: <span style='color: green;'>```Parthian = 298```</span>
  Parthian = 298,
  /// C++ enum variant: <span style='color: green;'>```Phoenician = 299```</span>
  Phoenician = 299,
  /// C++ enum variant: <span style='color: green;'>```PrakritLanguage = 300```</span>
  PrakritLanguage = 300,
  /// C++ enum variant: <span style='color: green;'>```Rejang = 301```</span>
  Rejang = 301,
  /// C++ enum variant: <span style='color: green;'>```Sabaean = 302```</span>
  Sabaean = 302,
  /// C++ enum variant: <span style='color: green;'>```Samaritan = 303```</span>
  Samaritan = 303,
  /// C++ enum variant: <span style='color: green;'>```Santali = 304```</span>
  Santali = 304,
  /// C++ enum variant: <span style='color: green;'>```Saurashtra = 305```</span>
  Saurashtra = 305,
  /// C++ enum variant: <span style='color: green;'>```Sora = 306```</span>
  Sora = 306,
  /// C++ enum variant: <span style='color: green;'>```Sylheti = 307```</span>
  Sylheti = 307,
  /// C++ enum variant: <span style='color: green;'>```Tagbanwa = 308```</span>
  Tagbanwa = 308,
  /// C++ enum variant: <span style='color: green;'>```TaiDam = 309```</span>
  TaiDam = 309,
  /// C++ enum variant: <span style='color: green;'>```TaiNua = 310```</span>
  TaiNua = 310,
  /// C++ enum variant: <span style='color: green;'>```Ugaritic = 311```</span>
  Ugaritic = 311,
  /// C++ enum variant: <span style='color: green;'>```Akoose = 312```</span>
  Akoose = 312,
  /// C++ enum variant: <span style='color: green;'>```Lakota = 313```</span>
  Lakota = 313,
  /// C++ enum variant: <span style='color: green;'>```StandardMoroccanTamazight = 314```</span>
  StandardMoroccanTamazight = 314,
  /// C++ enum variant: <span style='color: green;'>```Mapuche = 315```</span>
  Mapuche = 315,
  /// C++ enum variant: <span style='color: green;'>```CentralKurdish = 316```</span>
  CentralKurdish = 316,
  /// C++ enum variant: <span style='color: green;'>```LowerSorbian = 317```</span>
  LowerSorbian = 317,
  /// C++ enum variant: <span style='color: green;'>```UpperSorbian = 318```</span>
  UpperSorbian = 318,
  /// C++ enum variant: <span style='color: green;'>```Kenyang = 319```</span>
  Kenyang = 319,
  /// C++ enum variant: <span style='color: green;'>```Mohawk = 320```</span>
  Mohawk = 320,
  /// C++ enum variant: <span style='color: green;'>```Nko = 321```</span>
  Nko = 321,
  /// C++ enum variant: <span style='color: green;'>```Prussian = 322```</span>
  Prussian = 322,
  /// C++ enum variant: <span style='color: green;'>```Kiche = 323```</span>
  Kiche = 323,
  /// C++ enum variant: <span style='color: green;'>```SouthernSami = 324```</span>
  SouthernSami = 324,
  /// C++ enum variant: <span style='color: green;'>```LuleSami = 325```</span>
  LuleSami = 325,
  /// C++ enum variant: <span style='color: green;'>```InariSami = 326```</span>
  InariSami = 326,
  /// C++ enum variant: <span style='color: green;'>```SkoltSami = 327```</span>
  SkoltSami = 327,
  /// C++ enum variant: <span style='color: green;'>```Warlpiri = 328```</span>
  Warlpiri = 328,
  /// C++ enum variant: <span style='color: green;'>```ManichaeanMiddlePersian = 329```</span>
  ManichaeanMiddlePersian = 329,
  /// C++ enum variant: <span style='color: green;'>```Mende = 330```</span>
  Mende = 330,
  /// C++ enum variant: <span style='color: green;'>```AncientNorthArabian = 331```</span>
  AncientNorthArabian = 331,
  /// C++ enum variant: <span style='color: green;'>```LinearA = 332```</span>
  LinearA = 332,
  /// C++ enum variant: <span style='color: green;'>```HmongNjua = 333```</span>
  HmongNjua = 333,
  /// C++ enum variant: <span style='color: green;'>```Ho = 334```</span>
  Ho = 334,
  /// C++ enum variant: <span style='color: green;'>```Lezghian = 335```</span>
  Lezghian = 335,
  /// C++ enum variant: <span style='color: green;'>```Bassa = 336```</span>
  Bassa = 336,
  /// C++ enum variant: <span style='color: green;'>```Mono = 337```</span>
  Mono = 337,
  /// C++ enum variant: <span style='color: green;'>```TedimChin = 338```</span>
  TedimChin = 338,
  /// C++ enum variant: <span style='color: green;'>```Maithili = 339```</span>
  Maithili = 339,
  /// C++ enum variant: <span style='color: green;'>```Ahom = 340```</span>
  Ahom = 340,
  /// C++ enum variant: <span style='color: green;'>```AmericanSignLanguage = 341```</span>
  AmericanSignLanguage = 341,
  /// C++ enum variant: <span style='color: green;'>```ArdhamagadhiPrakrit = 342```</span>
  ArdhamagadhiPrakrit = 342,
  /// C++ enum variant: <span style='color: green;'>```Bhojpuri = 343```</span>
  Bhojpuri = 343,
  /// C++ enum variant: <span style='color: green;'>```HieroglyphicLuwian = 344```</span>
  HieroglyphicLuwian = 344,
  /// C++ enum variant: <span style='color: green;'>```LiteraryChinese = 345```</span>
  LiteraryChinese = 345,
  /// C++ enum variant: <span style='color: green;'>```Mazanderani = 346```</span>
  Mazanderani = 346,
  /// C++ enum variant: <span style='color: green;'>```Mru = 347```</span>
  Mru = 347,
  /// C++ enum variant: <span style='color: green;'>```Newari = 348```</span>
  Newari = 348,
  /// C++ enum variant: <span style='color: green;'>```NorthernLuri = 349```</span>
  NorthernLuri = 349,
  /// C++ enum variant: <span style='color: green;'>```Palauan = 350```</span>
  Palauan = 350,
  /// C++ enum variant: <span style='color: green;'>```Papiamento = 351```</span>
  Papiamento = 351,
  /// C++ enum variant: <span style='color: green;'>```Saraiki = 352```</span>
  Saraiki = 352,
  /// C++ enum variant: <span style='color: green;'>```TokelauLanguage = 353```</span>
  TokelauLanguage = 353,
  /// C++ enum variant: <span style='color: green;'>```TokPisin = 354```</span>
  TokPisin = 354,
  /// C++ enum variant: <span style='color: green;'>```TuvaluLanguage = 355```</span>
  TuvaluLanguage = 355,
  /// C++ enum variant: <span style='color: green;'>```UncodedLanguages = 356```</span>
  UncodedLanguages = 356,
  /// C++ enum variant: <span style='color: green;'>```Cantonese = 357```</span>
  Cantonese = 357,
  /// C++ enum variant: <span style='color: green;'>```Osage = 358```</span>
  Osage = 358,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```Tangut = 359```</span>
  /// - <span style='color: green;'>```LastLanguage = 359```</span>
  ///
  Tangut = 359,
}

/// C++ type: <span style='color: green;'>```QLocale```</span>
#[repr(C)]
pub struct Locale([u8; ::type_sizes::QT_CORE_LOCALE_LOCALE]);

impl ::cpp_utils::new_uninitialized::NewUninitialized for Locale {
  unsafe fn new_uninitialized() -> Locale {
    Locale(::std::mem::uninitialized())
  }
}

impl Locale {
  /// C++ method: <span style='color: green;'>```QString QLocale::amText() const```</span>
  ///
  ///
  pub fn am_text(&self) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_amText_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QString QLocale::bcp47Name() const```</span>
  ///
  ///
  pub fn bcp47_name(&self) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_bcp47Name_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```static QLocale QLocale::c()```</span>
  ///
  ///
  pub fn c() -> ::locale::Locale {
    {
      let mut object: ::locale::Locale =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_c_to_output(&mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```static QList<QLocale::Country> QLocale::countriesForLanguage(QLocale::Language lang)```</span>
  ///
  ///
  pub fn countries_for_language(lang: ::locale::Language) -> ::list::ListLocaleCountry {
    {
      let mut object: ::list::ListLocaleCountry =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_countriesForLanguage_to_output(lang, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::Country QLocale::country() const```</span>
  ///
  ///
  pub fn country(&self) -> ::locale::Country {
    unsafe { ::ffi::qt_core_c_QLocale_country(self as *const ::locale::Locale) }
  }

  /// C++ method: <span style='color: green;'>```static QString QLocale::countryToString(QLocale::Country country)```</span>
  ///
  ///
  pub fn country_to_string(country: ::locale::Country) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_countryToString_to_output(country, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QString QLocale::createSeparatedList(const QStringList& strl) const```</span>
  ///
  ///
  pub fn create_separated_list(&self, strl: &::string_list::StringList) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_createSeparatedList_to_output(self as *const ::locale::Locale,
                                                               strl as *const ::string_list::StringList,
                                                               &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::currencySymbol```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn currency_symbol(&self, ()) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::currencySymbol() const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn currency_symbol(&self, ::locale::CurrencySymbolFormat) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::currencySymbol(QLocale::CurrencySymbolFormat arg1 = ?) const```</span>
  ///
  ///
  pub fn currency_symbol<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleCurrencySymbolArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::dateFormat```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn date_format(&self, ()) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::dateFormat() const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn date_format(&self, ::locale::FormatType) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::dateFormat(QLocale::FormatType format = ?) const```</span>
  ///
  ///
  pub fn date_format<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleDateFormatArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::dateTimeFormat```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn date_time_format(&self, ()) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::dateTimeFormat() const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn date_time_format(&self, ::locale::FormatType) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::dateTimeFormat(QLocale::FormatType format = ?) const```</span>
  ///
  ///
  pub fn date_time_format<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleDateTimeFormatArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::dayName```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn day_name(&self, ::libc::c_int) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::dayName(int arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn day_name(&self, (::libc::c_int, ::locale::FormatType)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::dayName(int arg1, QLocale::FormatType format = ?) const```</span>
  ///
  ///
  pub fn day_name<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleDayNameArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QChar QLocale::decimalPoint() const```</span>
  ///
  ///
  pub fn decimal_point(&self) -> ::char::Char {
    {
      let mut object: ::char::Char = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_decimalPoint_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QChar QLocale::exponential() const```</span>
  ///
  ///
  pub fn exponential(&self) -> ::char::Char {
    {
      let mut object: ::char::Char = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_exponential_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QChar QLocale::groupSeparator() const```</span>
  ///
  ///
  pub fn group_separator(&self) -> ::char::Char {
    {
      let mut object: ::char::Char = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_groupSeparator_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::Language QLocale::language() const```</span>
  ///
  ///
  pub fn language(&self) -> ::locale::Language {
    unsafe { ::ffi::qt_core_c_QLocale_language(self as *const ::locale::Locale) }
  }

  /// C++ method: <span style='color: green;'>```static QString QLocale::languageToString(QLocale::Language language)```</span>
  ///
  ///
  pub fn language_to_string(language: ::locale::Language) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_languageToString_to_output(language, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```static QList<QLocale> QLocale::matchingLocales(QLocale::Language language, QLocale::Script script, QLocale::Country country)```</span>
  ///
  ///
  pub fn matching_locales(language: &::locale::Language,
                          script: &::locale::Script,
                          country: &::locale::Country)
                          -> ::list::ListLocale {
    {
      let mut object: ::list::ListLocale =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_matchingLocales_to_output(language as *const ::locale::Language,
                                                           script as *const ::locale::Script,
                                                           country as *const ::locale::Country,
                                                           &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::MeasurementSystem QLocale::measurementSystem() const```</span>
  ///
  ///
  pub fn measurement_system(&self) -> ::locale::MeasurementSystem {
    unsafe { ::ffi::qt_core_c_QLocale_measurementSystem(self as *const ::locale::Locale) }
  }

  /// C++ method: <span style='color: green;'>```QLocale::monthName```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn month_name(&self, ::libc::c_int) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::monthName(int arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn month_name(&self, (::libc::c_int, ::locale::FormatType)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::monthName(int arg1, QLocale::FormatType format = ?) const```</span>
  ///
  ///
  pub fn month_name<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleMonthNameArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QString QLocale::name() const```</span>
  ///
  ///
  pub fn name(&self) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_name_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QString QLocale::nativeCountryName() const```</span>
  ///
  ///
  pub fn native_country_name(&self) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_nativeCountryName_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QString QLocale::nativeLanguageName() const```</span>
  ///
  ///
  pub fn native_language_name(&self) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_nativeLanguageName_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QChar QLocale::negativeSign() const```</span>
  ///
  ///
  pub fn negative_sign(&self) -> ::char::Char {
    {
      let mut object: ::char::Char = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_negativeSign_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::QLocale```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn new(()) -> ::locale::Locale```<br>
  /// C++ method: <span style='color: green;'>```[constructor] void QLocale::QLocale()```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn new(::locale::Language) -> ::locale::Locale```<br>
  /// C++ method: <span style='color: green;'>```[constructor] void QLocale::QLocale(QLocale::Language language)```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn new((::locale::Language, ::locale::Country)) -> ::locale::Locale```<br>
  /// C++ method: <span style='color: green;'>```[constructor] void QLocale::QLocale(QLocale::Language language, QLocale::Country country = ?)```</span>
  ///
  ///
  ///
  /// ## Variant 4
  ///
  /// Rust arguments: ```fn new((::locale::Language, ::locale::Script, ::locale::Country)) -> ::locale::Locale```<br>
  /// C++ method: <span style='color: green;'>```[constructor] void QLocale::QLocale(QLocale::Language language, QLocale::Script script, QLocale::Country country)```</span>
  ///
  ///
  ///
  /// ## Variant 5
  ///
  /// Rust arguments: ```fn new(&::locale::Locale) -> ::locale::Locale```<br>
  /// C++ method: <span style='color: green;'>```[constructor] void QLocale::QLocale(const QLocale& other)```</span>
  ///
  ///
  ///
  /// ## Variant 6
  ///
  /// Rust arguments: ```fn new(&::string::String) -> ::locale::Locale```<br>
  /// C++ method: <span style='color: green;'>```[constructor] void QLocale::QLocale(const QString& name)```</span>
  ///
  ///
  pub fn new<Args>(args: Args) -> ::locale::Locale
    where Args: overloading::LocaleNewArgs
  {
    args.exec()
  }
  /// C++ method: <span style='color: green;'>```QFlags<QLocale::NumberOption> QLocale::numberOptions() const```</span>
  ///
  ///
  pub fn number_options(&self) -> ::flags::Flags<::locale::NumberOption> {
    let ffi_result = unsafe { ::ffi::qt_core_c_QLocale_numberOptions(self as *const ::locale::Locale) };
    ::flags::Flags::from_int(ffi_result as i32)
  }

  /// C++ method: <span style='color: green;'>```QLocale& QLocale::operator=(const QLocale& other)```</span>
  ///
  ///
  pub fn op_assign<'l0, 'l1>(&'l0 mut self, other: &'l1 ::locale::Locale) -> &'l0 mut ::locale::Locale {
    let ffi_result = unsafe {
      ::ffi::qt_core_c_QLocale_operator_assign(self as *mut ::locale::Locale,
                                               other as *const ::locale::Locale)
    };
    unsafe { ffi_result.as_mut() }.expect("Attempted to convert null pointer to reference")
  }

  /// C++ method: <span style='color: green;'>```bool QLocale::operator==(const QLocale& other) const```</span>
  ///
  ///
  pub fn op_eq(&self, other: &::locale::Locale) -> bool {
    unsafe {
      ::ffi::qt_core_c_QLocale_operator_eq(self as *const ::locale::Locale,
                                           other as *const ::locale::Locale)
    }
  }

  /// C++ method: <span style='color: green;'>```bool QLocale::operator!=(const QLocale& other) const```</span>
  ///
  ///
  pub fn op_neq(&self, other: &::locale::Locale) -> bool {
    unsafe {
      ::ffi::qt_core_c_QLocale_operator_neq(self as *const ::locale::Locale,
                                            other as *const ::locale::Locale)
    }
  }

  /// C++ method: <span style='color: green;'>```QChar QLocale::percent() const```</span>
  ///
  ///
  pub fn percent(&self) -> ::char::Char {
    {
      let mut object: ::char::Char = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_percent_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QString QLocale::pmText() const```</span>
  ///
  ///
  pub fn pm_text(&self) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_pmText_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QChar QLocale::positiveSign() const```</span>
  ///
  ///
  pub fn positive_sign(&self) -> ::char::Char {
    {
      let mut object: ::char::Char = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_positiveSign_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::quoteString```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn quote_string(&self, &::string::String) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::quoteString(const QString& str) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn quote_string(&self, (&::string::String, ::locale::QuotationStyle)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::quoteString(const QString& str, QLocale::QuotationStyle style = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn quote_string(&self, &::string_ref::StringRef) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::quoteString(const QStringRef& str) const```</span>
  ///
  ///
  ///
  /// ## Variant 4
  ///
  /// Rust arguments: ```fn quote_string(&self, (&::string_ref::StringRef, ::locale::QuotationStyle)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::quoteString(const QStringRef& str, QLocale::QuotationStyle style = ?) const```</span>
  ///
  ///
  pub fn quote_string<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleQuoteStringArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::Script QLocale::script() const```</span>
  ///
  ///
  pub fn script(&self) -> ::locale::Script {
    unsafe { ::ffi::qt_core_c_QLocale_script(self as *const ::locale::Locale) }
  }

  /// C++ method: <span style='color: green;'>```static QString QLocale::scriptToString(QLocale::Script script)```</span>
  ///
  ///
  pub fn script_to_string(script: ::locale::Script) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_scriptToString_to_output(script, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```static void QLocale::setDefault(const QLocale& locale)```</span>
  ///
  ///
  pub fn set_default(locale: &::locale::Locale) {
    unsafe { ::ffi::qt_core_c_QLocale_setDefault(locale as *const ::locale::Locale) }
  }

  /// C++ method: <span style='color: green;'>```void QLocale::setNumberOptions(QFlags<QLocale::NumberOption> options)```</span>
  ///
  ///
  pub fn set_number_options(&mut self, options: ::flags::Flags<::locale::NumberOption>) {
    unsafe {
      ::ffi::qt_core_c_QLocale_setNumberOptions(self as *mut ::locale::Locale,
                                                options.to_int() as ::libc::c_uint)
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::standaloneDayName```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn standalone_day_name(&self, ::libc::c_int) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::standaloneDayName(int arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn standalone_day_name(&self, (::libc::c_int, ::locale::FormatType)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::standaloneDayName(int arg1, QLocale::FormatType format = ?) const```</span>
  ///
  ///
  pub fn standalone_day_name<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleStandaloneDayNameArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::standaloneMonthName```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn standalone_month_name(&self, ::libc::c_int) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::standaloneMonthName(int arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn standalone_month_name(&self, (::libc::c_int, ::locale::FormatType)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::standaloneMonthName(int arg1, QLocale::FormatType format = ?) const```</span>
  ///
  ///
  pub fn standalone_month_name<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleStandaloneMonthNameArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```void QLocale::swap(QLocale& other)```</span>
  ///
  ///
  pub fn swap(&mut self, other: &mut ::locale::Locale) {
    unsafe {
      ::ffi::qt_core_c_QLocale_swap(self as *mut ::locale::Locale,
                                    other as *mut ::locale::Locale)
    }
  }

  /// C++ method: <span style='color: green;'>```static QLocale QLocale::system()```</span>
  ///
  ///
  pub fn system() -> ::locale::Locale {
    {
      let mut object: ::locale::Locale =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_system_to_output(&mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::timeFormat```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn time_format(&self, ()) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::timeFormat() const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn time_format(&self, ::locale::FormatType) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::timeFormat(QLocale::FormatType format = ?) const```</span>
  ///
  ///
  pub fn time_format<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleTimeFormatArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toCurrencyString```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_currency_string0(&self, ::libc::c_double) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(double arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_currency_string0(&self, (::libc::c_double, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(double arg1, const QString& symbol = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn to_currency_string0(&self, (::libc::c_double, &::string::String, ::libc::c_int)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(double arg1, const QString& symbol, int precision) const```</span>
  ///
  ///
  ///
  /// ## Variant 4
  ///
  /// Rust arguments: ```fn to_currency_string0(&self, ::libc::c_int) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(int arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 5
  ///
  /// Rust arguments: ```fn to_currency_string0(&self, (::libc::c_int, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(int arg1, const QString& symbol = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 6
  ///
  /// Rust arguments: ```fn to_currency_string0(&self, u64) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(qulonglong arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 7
  ///
  /// Rust arguments: ```fn to_currency_string0(&self, (u64, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(qulonglong arg1, const QString& symbol = ?) const```</span>
  ///
  ///
  pub fn to_currency_string0<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleToCurrencyString0Args<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toCurrencyString```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_currency_string1(&self, ::libc::c_float) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(float i) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_currency_string1(&self, (::libc::c_float, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(float i, const QString& symbol = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn to_currency_string1(&self, (::libc::c_float, &::string::String, ::libc::c_int)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(float i, const QString& symbol, int precision) const```</span>
  ///
  ///
  ///
  /// ## Variant 4
  ///
  /// Rust arguments: ```fn to_currency_string1(&self, i64) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(qlonglong arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 5
  ///
  /// Rust arguments: ```fn to_currency_string1(&self, (i64, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(qlonglong arg1, const QString& symbol = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 6
  ///
  /// Rust arguments: ```fn to_currency_string1(&self, ::libc::c_uint) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(unsigned int arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 7
  ///
  /// Rust arguments: ```fn to_currency_string1(&self, (::libc::c_uint, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(unsigned int arg1, const QString& symbol = ?) const```</span>
  ///
  ///
  pub fn to_currency_string1<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleToCurrencyString1Args<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toCurrencyString```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_currency_string2(&self, ::libc::c_short) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(short arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_currency_string2(&self, (::libc::c_short, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(short arg1, const QString& symbol = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn to_currency_string2(&self, ::libc::c_ushort) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(unsigned short arg1) const```</span>
  ///
  ///
  ///
  /// ## Variant 4
  ///
  /// Rust arguments: ```fn to_currency_string2(&self, (::libc::c_ushort, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toCurrencyString(unsigned short arg1, const QString& symbol = ?) const```</span>
  ///
  ///
  pub fn to_currency_string2<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleToCurrencyString2Args<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toDate```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_date(&self, &::string::String) -> ::date::Date```<br>
  /// C++ method: <span style='color: green;'>```QDate QLocale::toDate(const QString& string) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_date(&self, (&::string::String, ::locale::FormatType)) -> ::date::Date```<br>
  /// C++ method: <span style='color: green;'>```QDate QLocale::toDate(const QString& string, QLocale::FormatType arg2 = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn to_date(&self, (&::string::String, &::string::String)) -> ::date::Date```<br>
  /// C++ method: <span style='color: green;'>```QDate QLocale::toDate(const QString& string, const QString& format) const```</span>
  ///
  ///
  pub fn to_date<'largs, Args>(&'largs self, args: Args) -> ::date::Date
    where Args: overloading::LocaleToDateArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toDateTime```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_date_time(&self, &::string::String) -> ::date_time::DateTime```<br>
  /// C++ method: <span style='color: green;'>```QDateTime QLocale::toDateTime(const QString& string) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_date_time(&self, (&::string::String, ::locale::FormatType)) -> ::date_time::DateTime```<br>
  /// C++ method: <span style='color: green;'>```QDateTime QLocale::toDateTime(const QString& string, QLocale::FormatType format = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn to_date_time(&self, (&::string::String, &::string::String)) -> ::date_time::DateTime```<br>
  /// C++ method: <span style='color: green;'>```QDateTime QLocale::toDateTime(const QString& string, const QString& format) const```</span>
  ///
  ///
  pub fn to_date_time<'largs, Args>(&'largs self, args: Args) -> ::date_time::DateTime
    where Args: overloading::LocaleToDateTimeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toDouble```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_double(&self, &::string::String) -> ::libc::c_double```<br>
  /// C++ method: <span style='color: green;'>```double QLocale::toDouble(const QString& s) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_double(&self, &::string_ref::StringRef) -> ::libc::c_double```<br>
  /// C++ method: <span style='color: green;'>```double QLocale::toDouble(const QStringRef& s) const```</span>
  ///
  ///
  pub fn to_double<'largs, Args>(&'largs self, args: Args) -> ::libc::c_double
    where Args: overloading::LocaleToDoubleArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toDouble```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_double_unsafe(&self, (&::string::String, *mut bool)) -> ::libc::c_double```<br>
  /// C++ method: <span style='color: green;'>```double QLocale::toDouble(const QString& s, bool* ok = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_double_unsafe(&self, (&::string_ref::StringRef, *mut bool)) -> ::libc::c_double```<br>
  /// C++ method: <span style='color: green;'>```double QLocale::toDouble(const QStringRef& s, bool* ok = ?) const```</span>
  ///
  ///
  pub unsafe fn to_double_unsafe<'largs, Args>(&'largs self, args: Args) -> ::libc::c_double
    where Args: overloading::LocaleToDoubleUnsafeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toFloat```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_float(&self, &::string::String) -> ::libc::c_float```<br>
  /// C++ method: <span style='color: green;'>```float QLocale::toFloat(const QString& s) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_float(&self, &::string_ref::StringRef) -> ::libc::c_float```<br>
  /// C++ method: <span style='color: green;'>```float QLocale::toFloat(const QStringRef& s) const```</span>
  ///
  ///
  pub fn to_float<'largs, Args>(&'largs self, args: Args) -> ::libc::c_float
    where Args: overloading::LocaleToFloatArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toFloat```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_float_unsafe(&self, (&::string::String, *mut bool)) -> ::libc::c_float```<br>
  /// C++ method: <span style='color: green;'>```float QLocale::toFloat(const QString& s, bool* ok = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_float_unsafe(&self, (&::string_ref::StringRef, *mut bool)) -> ::libc::c_float```<br>
  /// C++ method: <span style='color: green;'>```float QLocale::toFloat(const QStringRef& s, bool* ok = ?) const```</span>
  ///
  ///
  pub unsafe fn to_float_unsafe<'largs, Args>(&'largs self, args: Args) -> ::libc::c_float
    where Args: overloading::LocaleToFloatUnsafeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toInt```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_int(&self, &::string::String) -> ::libc::c_int```<br>
  /// C++ method: <span style='color: green;'>```int QLocale::toInt(const QString& s) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_int(&self, &::string_ref::StringRef) -> ::libc::c_int```<br>
  /// C++ method: <span style='color: green;'>```int QLocale::toInt(const QStringRef& s) const```</span>
  ///
  ///
  pub fn to_int<'largs, Args>(&'largs self, args: Args) -> ::libc::c_int
    where Args: overloading::LocaleToIntArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toInt```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_int_unsafe(&self, (&::string::String, *mut bool)) -> ::libc::c_int```<br>
  /// C++ method: <span style='color: green;'>```int QLocale::toInt(const QString& s, bool* ok = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_int_unsafe(&self, (&::string_ref::StringRef, *mut bool)) -> ::libc::c_int```<br>
  /// C++ method: <span style='color: green;'>```int QLocale::toInt(const QStringRef& s, bool* ok = ?) const```</span>
  ///
  ///
  pub unsafe fn to_int_unsafe<'largs, Args>(&'largs self, args: Args) -> ::libc::c_int
    where Args: overloading::LocaleToIntUnsafeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toLongLong```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_long_long(&self, &::string::String) -> i64```<br>
  /// C++ method: <span style='color: green;'>```qlonglong QLocale::toLongLong(const QString& s) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_long_long(&self, &::string_ref::StringRef) -> i64```<br>
  /// C++ method: <span style='color: green;'>```qlonglong QLocale::toLongLong(const QStringRef& s) const```</span>
  ///
  ///
  pub fn to_long_long<'largs, Args>(&'largs self, args: Args) -> i64
    where Args: overloading::LocaleToLongLongArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toLongLong```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_long_long_unsafe(&self, (&::string::String, *mut bool)) -> i64```<br>
  /// C++ method: <span style='color: green;'>```qlonglong QLocale::toLongLong(const QString& s, bool* ok = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_long_long_unsafe(&self, (&::string_ref::StringRef, *mut bool)) -> i64```<br>
  /// C++ method: <span style='color: green;'>```qlonglong QLocale::toLongLong(const QStringRef& s, bool* ok = ?) const```</span>
  ///
  ///
  pub unsafe fn to_long_long_unsafe<'largs, Args>(&'largs self, args: Args) -> i64
    where Args: overloading::LocaleToLongLongUnsafeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QString QLocale::toLower(const QString& str) const```</span>
  ///
  ///
  pub fn to_lower(&self, str: &::string::String) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_toLower_to_output(self as *const ::locale::Locale,
                                                   str as *const ::string::String,
                                                   &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QLocale::toShort```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_short(&self, &::string::String) -> ::libc::c_short```<br>
  /// C++ method: <span style='color: green;'>```short QLocale::toShort(const QString& s) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_short(&self, &::string_ref::StringRef) -> ::libc::c_short```<br>
  /// C++ method: <span style='color: green;'>```short QLocale::toShort(const QStringRef& s) const```</span>
  ///
  ///
  pub fn to_short<'largs, Args>(&'largs self, args: Args) -> ::libc::c_short
    where Args: overloading::LocaleToShortArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toShort```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_short_unsafe(&self, (&::string::String, *mut bool)) -> ::libc::c_short```<br>
  /// C++ method: <span style='color: green;'>```short QLocale::toShort(const QString& s, bool* ok = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_short_unsafe(&self, (&::string_ref::StringRef, *mut bool)) -> ::libc::c_short```<br>
  /// C++ method: <span style='color: green;'>```short QLocale::toShort(const QStringRef& s, bool* ok = ?) const```</span>
  ///
  ///
  pub unsafe fn to_short_unsafe<'largs, Args>(&'largs self, args: Args) -> ::libc::c_short
    where Args: overloading::LocaleToShortUnsafeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toString```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_string0(&self, &::date::Date) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QDate& date) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_string0(&self, (&::date::Date, ::locale::FormatType)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QDate& date, QLocale::FormatType format = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn to_string0(&self, (&::date::Date, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QDate& date, const QString& formatStr) const```</span>
  ///
  ///
  ///
  /// ## Variant 4
  ///
  /// Rust arguments: ```fn to_string0(&self, &::date_time::DateTime) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QDateTime& dateTime) const```</span>
  ///
  ///
  ///
  /// ## Variant 5
  ///
  /// Rust arguments: ```fn to_string0(&self, (&::date_time::DateTime, ::locale::FormatType)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QDateTime& dateTime, QLocale::FormatType format = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 6
  ///
  /// Rust arguments: ```fn to_string0(&self, (&::date_time::DateTime, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QDateTime& dateTime, const QString& format) const```</span>
  ///
  ///
  ///
  /// ## Variant 7
  ///
  /// Rust arguments: ```fn to_string0(&self, &::time::Time) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QTime& time) const```</span>
  ///
  ///
  ///
  /// ## Variant 8
  ///
  /// Rust arguments: ```fn to_string0(&self, (&::time::Time, ::locale::FormatType)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QTime& time, QLocale::FormatType format = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 9
  ///
  /// Rust arguments: ```fn to_string0(&self, (&::time::Time, &::string::String)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(const QTime& time, const QString& formatStr) const```</span>
  ///
  ///
  ///
  /// ## Variant 10
  ///
  /// Rust arguments: ```fn to_string0(&self, ::libc::c_double) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(double i) const```</span>
  ///
  ///
  ///
  /// ## Variant 11
  ///
  /// Rust arguments: ```fn to_string0(&self, (::libc::c_double, ::libc::c_char)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(double i, char f = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 12
  ///
  /// Rust arguments: ```fn to_string0(&self, (::libc::c_double, ::libc::c_char, ::libc::c_int)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(double i, char f = ?, int prec = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 13
  ///
  /// Rust arguments: ```fn to_string0(&self, ::libc::c_int) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(int i) const```</span>
  ///
  ///
  ///
  /// ## Variant 14
  ///
  /// Rust arguments: ```fn to_string0(&self, u64) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(qulonglong i) const```</span>
  ///
  ///
  pub fn to_string0<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleToString0Args<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toString```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_string1(&self, ::libc::c_float) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(float i) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_string1(&self, (::libc::c_float, ::libc::c_char)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(float i, char f = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn to_string1(&self, (::libc::c_float, ::libc::c_char, ::libc::c_int)) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(float i, char f = ?, int prec = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 4
  ///
  /// Rust arguments: ```fn to_string1(&self, i64) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(qlonglong i) const```</span>
  ///
  ///
  ///
  /// ## Variant 5
  ///
  /// Rust arguments: ```fn to_string1(&self, ::libc::c_uint) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(unsigned int i) const```</span>
  ///
  ///
  pub fn to_string1<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleToString1Args<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toString```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_string2(&self, ::libc::c_short) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(short i) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_string2(&self, ::libc::c_ushort) -> ::string::String```<br>
  /// C++ method: <span style='color: green;'>```QString QLocale::toString(unsigned short i) const```</span>
  ///
  ///
  pub fn to_string2<'largs, Args>(&'largs self, args: Args) -> ::string::String
    where Args: overloading::LocaleToString2Args<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toTime```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_time(&self, &::string::String) -> ::time::Time```<br>
  /// C++ method: <span style='color: green;'>```QTime QLocale::toTime(const QString& string) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_time(&self, (&::string::String, ::locale::FormatType)) -> ::time::Time```<br>
  /// C++ method: <span style='color: green;'>```QTime QLocale::toTime(const QString& string, QLocale::FormatType arg2 = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 3
  ///
  /// Rust arguments: ```fn to_time(&self, (&::string::String, &::string::String)) -> ::time::Time```<br>
  /// C++ method: <span style='color: green;'>```QTime QLocale::toTime(const QString& string, const QString& format) const```</span>
  ///
  ///
  pub fn to_time<'largs, Args>(&'largs self, args: Args) -> ::time::Time
    where Args: overloading::LocaleToTimeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toUInt```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_u_int(&self, &::string::String) -> ::libc::c_uint```<br>
  /// C++ method: <span style='color: green;'>```unsigned int QLocale::toUInt(const QString& s) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_u_int(&self, &::string_ref::StringRef) -> ::libc::c_uint```<br>
  /// C++ method: <span style='color: green;'>```unsigned int QLocale::toUInt(const QStringRef& s) const```</span>
  ///
  ///
  pub fn to_u_int<'largs, Args>(&'largs self, args: Args) -> ::libc::c_uint
    where Args: overloading::LocaleToUIntArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toUInt```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_u_int_unsafe(&self, (&::string::String, *mut bool)) -> ::libc::c_uint```<br>
  /// C++ method: <span style='color: green;'>```unsigned int QLocale::toUInt(const QString& s, bool* ok = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_u_int_unsafe(&self, (&::string_ref::StringRef, *mut bool)) -> ::libc::c_uint```<br>
  /// C++ method: <span style='color: green;'>```unsigned int QLocale::toUInt(const QStringRef& s, bool* ok = ?) const```</span>
  ///
  ///
  pub unsafe fn to_u_int_unsafe<'largs, Args>(&'largs self, args: Args) -> ::libc::c_uint
    where Args: overloading::LocaleToUIntUnsafeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toULongLong```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_u_long_long(&self, &::string::String) -> u64```<br>
  /// C++ method: <span style='color: green;'>```qulonglong QLocale::toULongLong(const QString& s) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_u_long_long(&self, &::string_ref::StringRef) -> u64```<br>
  /// C++ method: <span style='color: green;'>```qulonglong QLocale::toULongLong(const QStringRef& s) const```</span>
  ///
  ///
  pub fn to_u_long_long<'largs, Args>(&'largs self, args: Args) -> u64
    where Args: overloading::LocaleToULongLongArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toULongLong```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_u_long_long_unsafe(&self, (&::string::String, *mut bool)) -> u64```<br>
  /// C++ method: <span style='color: green;'>```qulonglong QLocale::toULongLong(const QString& s, bool* ok = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_u_long_long_unsafe(&self, (&::string_ref::StringRef, *mut bool)) -> u64```<br>
  /// C++ method: <span style='color: green;'>```qulonglong QLocale::toULongLong(const QStringRef& s, bool* ok = ?) const```</span>
  ///
  ///
  pub unsafe fn to_u_long_long_unsafe<'largs, Args>(&'largs self, args: Args) -> u64
    where Args: overloading::LocaleToULongLongUnsafeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toUShort```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_u_short(&self, &::string::String) -> ::libc::c_ushort```<br>
  /// C++ method: <span style='color: green;'>```unsigned short QLocale::toUShort(const QString& s) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_u_short(&self, &::string_ref::StringRef) -> ::libc::c_ushort```<br>
  /// C++ method: <span style='color: green;'>```unsigned short QLocale::toUShort(const QStringRef& s) const```</span>
  ///
  ///
  pub fn to_u_short<'largs, Args>(&'largs self, args: Args) -> ::libc::c_ushort
    where Args: overloading::LocaleToUShortArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QLocale::toUShort```</span>
  ///
  /// This is an overloaded function. Available variants:
  ///
  ///
  ///
  /// ## Variant 1
  ///
  /// Rust arguments: ```fn to_u_short_unsafe(&self, (&::string::String, *mut bool)) -> ::libc::c_ushort```<br>
  /// C++ method: <span style='color: green;'>```unsigned short QLocale::toUShort(const QString& s, bool* ok = ?) const```</span>
  ///
  ///
  ///
  /// ## Variant 2
  ///
  /// Rust arguments: ```fn to_u_short_unsafe(&self, (&::string_ref::StringRef, *mut bool)) -> ::libc::c_ushort```<br>
  /// C++ method: <span style='color: green;'>```unsigned short QLocale::toUShort(const QStringRef& s, bool* ok = ?) const```</span>
  ///
  ///
  pub unsafe fn to_u_short_unsafe<'largs, Args>(&'largs self, args: Args) -> ::libc::c_ushort
    where Args: overloading::LocaleToUShortUnsafeArgs<'largs>
  {
    args.exec(self)
  }
  /// C++ method: <span style='color: green;'>```QString QLocale::toUpper(const QString& str) const```</span>
  ///
  ///
  pub fn to_upper(&self, str: &::string::String) -> ::string::String {
    {
      let mut object: ::string::String =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_toUpper_to_output(self as *const ::locale::Locale,
                                                   str as *const ::string::String,
                                                   &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QStringList QLocale::uiLanguages() const```</span>
  ///
  ///
  pub fn ui_languages(&self) -> ::string_list::StringList {
    {
      let mut object: ::string_list::StringList =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_uiLanguages_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QList<Qt::DayOfWeek> QLocale::weekdays() const```</span>
  ///
  ///
  pub fn weekdays(&self) -> ::list::ListQtDayOfWeek {
    {
      let mut object: ::list::ListQtDayOfWeek =
        unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_weekdays_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }

  /// C++ method: <span style='color: green;'>```QChar QLocale::zeroDigit() const```</span>
  ///
  ///
  pub fn zero_digit(&self) -> ::char::Char {
    {
      let mut object: ::char::Char = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
      unsafe {
        ::ffi::qt_core_c_QLocale_zeroDigit_to_output(self as *const ::locale::Locale, &mut object);
      }
      object
    }
  }
}

impl Drop for ::locale::Locale {
  /// C++ method: <span style='color: green;'>```[destructor] void QLocale::~QLocale()```</span>
  ///
  ///
  fn drop(&mut self) {
    unsafe { ::ffi::qt_core_c_QLocale_destructor(self as *mut ::locale::Locale) }
  }
}

/// C++ type: <span style='color: green;'>```QLocale::MeasurementSystem```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum MeasurementSystem {
  /// C++ enum variant: <span style='color: green;'>```MetricSystem = 0```</span>
  Metric = 0,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```ImperialUSSystem = 1```</span>
  /// - <span style='color: green;'>```ImperialSystem = 1```</span>
  ///
  ImperialUS = 1,
  /// C++ enum variant: <span style='color: green;'>```ImperialUKSystem = 2```</span>
  ImperialUK = 2,
}

/// C++ type: <span style='color: green;'>```QLocale::NumberOption```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum NumberOption {
  /// C++ enum variant: <span style='color: green;'>```DefaultNumberOptions = 0```</span>
  DefaultNumberOptions = 0,
  /// C++ enum variant: <span style='color: green;'>```OmitGroupSeparator = 1```</span>
  OmitGroupSeparator = 1,
  /// C++ enum variant: <span style='color: green;'>```RejectGroupSeparator = 2```</span>
  RejectGroupSeparator = 2,
  /// C++ enum variant: <span style='color: green;'>```OmitLeadingZeroInExponent = 4```</span>
  OmitLeadingZeroInExponent = 4,
  /// C++ enum variant: <span style='color: green;'>```RejectLeadingZeroInExponent = 8```</span>
  RejectLeadingZeroInExponent = 8,
  /// C++ enum variant: <span style='color: green;'>```IncludeTrailingZeroesAfterDot = 16```</span>
  IncludeTrailingZeroesAfterDot = 16,
  /// C++ enum variant: <span style='color: green;'>```RejectTrailingZeroesAfterDot = 32```</span>
  RejectTrailingZeroesAfterDot = 32,
}

impl ::flags::FlaggableEnum for NumberOption {
  fn to_flag_value(self) -> ::libc::c_int {
    self as ::libc::c_int
  }
  fn enum_name() -> &'static str {
    "NumberOption"
  }
}

/// C++ type: <span style='color: green;'>```QLocale::QuotationStyle```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum QuotationStyle {
  /// C++ enum variant: <span style='color: green;'>```StandardQuotation = 0```</span>
  Standard = 0,
  /// C++ enum variant: <span style='color: green;'>```AlternateQuotation = 1```</span>
  Alternate = 1,
}

/// C++ type: <span style='color: green;'>```QLocale::Script```</span>
#[derive(Debug, PartialEq, Eq, Clone)]
#[repr(C)]
pub enum Script {
  /// C++ enum variant: <span style='color: green;'>```AnyScript = 0```</span>
  Any = 0,
  /// C++ enum variant: <span style='color: green;'>```ArabicScript = 1```</span>
  Arabic = 1,
  /// C++ enum variant: <span style='color: green;'>```CyrillicScript = 2```</span>
  Cyrillic = 2,
  /// C++ enum variant: <span style='color: green;'>```DeseretScript = 3```</span>
  Deseret = 3,
  /// C++ enum variant: <span style='color: green;'>```GurmukhiScript = 4```</span>
  Gurmukhi = 4,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```SimplifiedHanScript = 5```</span>
  /// - <span style='color: green;'>```SimplifiedChineseScript = 5```</span>
  ///
  SimplifiedHan = 5,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```TraditionalHanScript = 6```</span>
  /// - <span style='color: green;'>```TraditionalChineseScript = 6```</span>
  ///
  TraditionalHan = 6,
  /// C++ enum variant: <span style='color: green;'>```LatinScript = 7```</span>
  Latin = 7,
  /// C++ enum variant: <span style='color: green;'>```MongolianScript = 8```</span>
  Mongolian = 8,
  /// C++ enum variant: <span style='color: green;'>```TifinaghScript = 9```</span>
  Tifinagh = 9,
  /// C++ enum variant: <span style='color: green;'>```ArmenianScript = 10```</span>
  Armenian = 10,
  /// C++ enum variant: <span style='color: green;'>```BengaliScript = 11```</span>
  Bengali = 11,
  /// C++ enum variant: <span style='color: green;'>```CherokeeScript = 12```</span>
  Cherokee = 12,
  /// C++ enum variant: <span style='color: green;'>```DevanagariScript = 13```</span>
  Devanagari = 13,
  /// C++ enum variant: <span style='color: green;'>```EthiopicScript = 14```</span>
  Ethiopic = 14,
  /// C++ enum variant: <span style='color: green;'>```GeorgianScript = 15```</span>
  Georgian = 15,
  /// C++ enum variant: <span style='color: green;'>```GreekScript = 16```</span>
  Greek = 16,
  /// C++ enum variant: <span style='color: green;'>```GujaratiScript = 17```</span>
  Gujarati = 17,
  /// C++ enum variant: <span style='color: green;'>```HebrewScript = 18```</span>
  Hebrew = 18,
  /// C++ enum variant: <span style='color: green;'>```JapaneseScript = 19```</span>
  Japanese = 19,
  /// C++ enum variant: <span style='color: green;'>```KhmerScript = 20```</span>
  Khmer = 20,
  /// C++ enum variant: <span style='color: green;'>```KannadaScript = 21```</span>
  Kannada = 21,
  /// C++ enum variant: <span style='color: green;'>```KoreanScript = 22```</span>
  Korean = 22,
  /// C++ enum variant: <span style='color: green;'>```LaoScript = 23```</span>
  Lao = 23,
  /// C++ enum variant: <span style='color: green;'>```MalayalamScript = 24```</span>
  Malayalam = 24,
  /// C++ enum variant: <span style='color: green;'>```MyanmarScript = 25```</span>
  Myanmar = 25,
  /// C++ enum variant: <span style='color: green;'>```OriyaScript = 26```</span>
  Oriya = 26,
  /// C++ enum variant: <span style='color: green;'>```TamilScript = 27```</span>
  Tamil = 27,
  /// C++ enum variant: <span style='color: green;'>```TeluguScript = 28```</span>
  Telugu = 28,
  /// C++ enum variant: <span style='color: green;'>```ThaanaScript = 29```</span>
  Thaana = 29,
  /// C++ enum variant: <span style='color: green;'>```ThaiScript = 30```</span>
  Thai = 30,
  /// C++ enum variant: <span style='color: green;'>```TibetanScript = 31```</span>
  Tibetan = 31,
  /// C++ enum variant: <span style='color: green;'>```SinhalaScript = 32```</span>
  Sinhala = 32,
  /// C++ enum variant: <span style='color: green;'>```SyriacScript = 33```</span>
  Syriac = 33,
  /// C++ enum variant: <span style='color: green;'>```YiScript = 34```</span>
  Yi = 34,
  /// C++ enum variant: <span style='color: green;'>```VaiScript = 35```</span>
  Vai = 35,
  /// C++ enum variant: <span style='color: green;'>```AvestanScript = 36```</span>
  Avestan = 36,
  /// C++ enum variant: <span style='color: green;'>```BalineseScript = 37```</span>
  Balinese = 37,
  /// C++ enum variant: <span style='color: green;'>```BamumScript = 38```</span>
  Bamum = 38,
  /// C++ enum variant: <span style='color: green;'>```BatakScript = 39```</span>
  Batak = 39,
  /// C++ enum variant: <span style='color: green;'>```BopomofoScript = 40```</span>
  Bopomofo = 40,
  /// C++ enum variant: <span style='color: green;'>```BrahmiScript = 41```</span>
  Brahmi = 41,
  /// C++ enum variant: <span style='color: green;'>```BugineseScript = 42```</span>
  Buginese = 42,
  /// C++ enum variant: <span style='color: green;'>```BuhidScript = 43```</span>
  Buhid = 43,
  /// C++ enum variant: <span style='color: green;'>```CanadianAboriginalScript = 44```</span>
  CanadianAboriginal = 44,
  /// C++ enum variant: <span style='color: green;'>```CarianScript = 45```</span>
  Carian = 45,
  /// C++ enum variant: <span style='color: green;'>```ChakmaScript = 46```</span>
  Chakma = 46,
  /// C++ enum variant: <span style='color: green;'>```ChamScript = 47```</span>
  Cham = 47,
  /// C++ enum variant: <span style='color: green;'>```CopticScript = 48```</span>
  Coptic = 48,
  /// C++ enum variant: <span style='color: green;'>```CypriotScript = 49```</span>
  Cypriot = 49,
  /// C++ enum variant: <span style='color: green;'>```EgyptianHieroglyphsScript = 50```</span>
  EgyptianHieroglyphs = 50,
  /// C++ enum variant: <span style='color: green;'>```FraserScript = 51```</span>
  Fraser = 51,
  /// C++ enum variant: <span style='color: green;'>```GlagoliticScript = 52```</span>
  Glagolitic = 52,
  /// C++ enum variant: <span style='color: green;'>```GothicScript = 53```</span>
  Gothic = 53,
  /// C++ enum variant: <span style='color: green;'>```HanScript = 54```</span>
  Han = 54,
  /// C++ enum variant: <span style='color: green;'>```HangulScript = 55```</span>
  Hangul = 55,
  /// C++ enum variant: <span style='color: green;'>```HanunooScript = 56```</span>
  Hanunoo = 56,
  /// C++ enum variant: <span style='color: green;'>```ImperialAramaicScript = 57```</span>
  ImperialAramaic = 57,
  /// C++ enum variant: <span style='color: green;'>```InscriptionalPahlaviScript = 58```</span>
  InscriptionalPahlavi = 58,
  /// C++ enum variant: <span style='color: green;'>```InscriptionalParthianScript = 59```</span>
  InscriptionalParthian = 59,
  /// C++ enum variant: <span style='color: green;'>```JavaneseScript = 60```</span>
  Javanese = 60,
  /// C++ enum variant: <span style='color: green;'>```KaithiScript = 61```</span>
  Kaithi = 61,
  /// C++ enum variant: <span style='color: green;'>```KatakanaScript = 62```</span>
  Katakana = 62,
  /// C++ enum variant: <span style='color: green;'>```KayahLiScript = 63```</span>
  KayahLi = 63,
  /// C++ enum variant: <span style='color: green;'>```KharoshthiScript = 64```</span>
  Kharoshthi = 64,
  /// C++ enum variant: <span style='color: green;'>```LannaScript = 65```</span>
  Lanna = 65,
  /// C++ enum variant: <span style='color: green;'>```LepchaScript = 66```</span>
  Lepcha = 66,
  /// C++ enum variant: <span style='color: green;'>```LimbuScript = 67```</span>
  Limbu = 67,
  /// C++ enum variant: <span style='color: green;'>```LinearBScript = 68```</span>
  LinearB = 68,
  /// C++ enum variant: <span style='color: green;'>```LycianScript = 69```</span>
  Lycian = 69,
  /// C++ enum variant: <span style='color: green;'>```LydianScript = 70```</span>
  Lydian = 70,
  /// C++ enum variant: <span style='color: green;'>```MandaeanScript = 71```</span>
  Mandaean = 71,
  /// C++ enum variant: <span style='color: green;'>```MeiteiMayekScript = 72```</span>
  MeiteiMayek = 72,
  /// C++ enum variant: <span style='color: green;'>```MeroiticScript = 73```</span>
  Meroitic = 73,
  /// C++ enum variant: <span style='color: green;'>```MeroiticCursiveScript = 74```</span>
  MeroiticCursive = 74,
  /// C++ enum variant: <span style='color: green;'>```NkoScript = 75```</span>
  Nko = 75,
  /// C++ enum variant: <span style='color: green;'>```NewTaiLueScript = 76```</span>
  NewTaiLue = 76,
  /// C++ enum variant: <span style='color: green;'>```OghamScript = 77```</span>
  Ogham = 77,
  /// C++ enum variant: <span style='color: green;'>```OlChikiScript = 78```</span>
  OlChiki = 78,
  /// C++ enum variant: <span style='color: green;'>```OldItalicScript = 79```</span>
  OldItalic = 79,
  /// C++ enum variant: <span style='color: green;'>```OldPersianScript = 80```</span>
  OldPersian = 80,
  /// C++ enum variant: <span style='color: green;'>```OldSouthArabianScript = 81```</span>
  OldSouthArabian = 81,
  /// C++ enum variant: <span style='color: green;'>```OrkhonScript = 82```</span>
  Orkhon = 82,
  /// C++ enum variant: <span style='color: green;'>```OsmanyaScript = 83```</span>
  Osmanya = 83,
  /// C++ enum variant: <span style='color: green;'>```PhagsPaScript = 84```</span>
  PhagsPa = 84,
  /// C++ enum variant: <span style='color: green;'>```PhoenicianScript = 85```</span>
  Phoenician = 85,
  /// C++ enum variant: <span style='color: green;'>```PollardPhoneticScript = 86```</span>
  PollardPhonetic = 86,
  /// C++ enum variant: <span style='color: green;'>```RejangScript = 87```</span>
  Rejang = 87,
  /// C++ enum variant: <span style='color: green;'>```RunicScript = 88```</span>
  Runic = 88,
  /// C++ enum variant: <span style='color: green;'>```SamaritanScript = 89```</span>
  Samaritan = 89,
  /// C++ enum variant: <span style='color: green;'>```SaurashtraScript = 90```</span>
  Saurashtra = 90,
  /// C++ enum variant: <span style='color: green;'>```SharadaScript = 91```</span>
  Sharada = 91,
  /// C++ enum variant: <span style='color: green;'>```ShavianScript = 92```</span>
  Shavian = 92,
  /// C++ enum variant: <span style='color: green;'>```SoraSompengScript = 93```</span>
  SoraSompeng = 93,
  /// C++ enum variant: <span style='color: green;'>```CuneiformScript = 94```</span>
  Cuneiform = 94,
  /// C++ enum variant: <span style='color: green;'>```SundaneseScript = 95```</span>
  Sundanese = 95,
  /// C++ enum variant: <span style='color: green;'>```SylotiNagriScript = 96```</span>
  SylotiNagri = 96,
  /// C++ enum variant: <span style='color: green;'>```TagalogScript = 97```</span>
  Tagalog = 97,
  /// C++ enum variant: <span style='color: green;'>```TagbanwaScript = 98```</span>
  Tagbanwa = 98,
  /// C++ enum variant: <span style='color: green;'>```TaiLeScript = 99```</span>
  TaiLe = 99,
  /// C++ enum variant: <span style='color: green;'>```TaiVietScript = 100```</span>
  TaiViet = 100,
  /// C++ enum variant: <span style='color: green;'>```TakriScript = 101```</span>
  Takri = 101,
  /// C++ enum variant: <span style='color: green;'>```UgariticScript = 102```</span>
  Ugaritic = 102,
  /// C++ enum variant: <span style='color: green;'>```BrailleScript = 103```</span>
  Braille = 103,
  /// C++ enum variant: <span style='color: green;'>```HiraganaScript = 104```</span>
  Hiragana = 104,
  /// C++ enum variant: <span style='color: green;'>```CaucasianAlbanianScript = 105```</span>
  CaucasianAlbanian = 105,
  /// C++ enum variant: <span style='color: green;'>```BassaVahScript = 106```</span>
  BassaVah = 106,
  /// C++ enum variant: <span style='color: green;'>```DuployanScript = 107```</span>
  Duployan = 107,
  /// C++ enum variant: <span style='color: green;'>```ElbasanScript = 108```</span>
  Elbasan = 108,
  /// C++ enum variant: <span style='color: green;'>```GranthaScript = 109```</span>
  Grantha = 109,
  /// C++ enum variant: <span style='color: green;'>```PahawhHmongScript = 110```</span>
  PahawhHmong = 110,
  /// C++ enum variant: <span style='color: green;'>```KhojkiScript = 111```</span>
  Khojki = 111,
  /// C++ enum variant: <span style='color: green;'>```LinearAScript = 112```</span>
  LinearA = 112,
  /// C++ enum variant: <span style='color: green;'>```MahajaniScript = 113```</span>
  Mahajani = 113,
  /// C++ enum variant: <span style='color: green;'>```ManichaeanScript = 114```</span>
  Manichaean = 114,
  /// C++ enum variant: <span style='color: green;'>```MendeKikakuiScript = 115```</span>
  MendeKikakui = 115,
  /// C++ enum variant: <span style='color: green;'>```ModiScript = 116```</span>
  Modi = 116,
  /// C++ enum variant: <span style='color: green;'>```MroScript = 117```</span>
  Mro = 117,
  /// C++ enum variant: <span style='color: green;'>```OldNorthArabianScript = 118```</span>
  OldNorthArabian = 118,
  /// C++ enum variant: <span style='color: green;'>```NabataeanScript = 119```</span>
  Nabataean = 119,
  /// C++ enum variant: <span style='color: green;'>```PalmyreneScript = 120```</span>
  Palmyrene = 120,
  /// C++ enum variant: <span style='color: green;'>```PauCinHauScript = 121```</span>
  PauCinHau = 121,
  /// C++ enum variant: <span style='color: green;'>```OldPermicScript = 122```</span>
  OldPermic = 122,
  /// C++ enum variant: <span style='color: green;'>```PsalterPahlaviScript = 123```</span>
  PsalterPahlavi = 123,
  /// C++ enum variant: <span style='color: green;'>```SiddhamScript = 124```</span>
  Siddham = 124,
  /// C++ enum variant: <span style='color: green;'>```KhudawadiScript = 125```</span>
  Khudawadi = 125,
  /// C++ enum variant: <span style='color: green;'>```TirhutaScript = 126```</span>
  Tirhuta = 126,
  /// C++ enum variant: <span style='color: green;'>```VarangKshitiScript = 127```</span>
  VarangKshiti = 127,
  /// C++ enum variant: <span style='color: green;'>```AhomScript = 128```</span>
  Ahom = 128,
  /// C++ enum variant: <span style='color: green;'>```AnatolianHieroglyphsScript = 129```</span>
  AnatolianHieroglyphs = 129,
  /// C++ enum variant: <span style='color: green;'>```HatranScript = 130```</span>
  Hatran = 130,
  /// C++ enum variant: <span style='color: green;'>```MultaniScript = 131```</span>
  Multani = 131,
  /// C++ enum variant: <span style='color: green;'>```OldHungarianScript = 132```</span>
  OldHungarian = 132,
  /// C++ enum variant: <span style='color: green;'>```SignWritingScript = 133```</span>
  SignWriting = 133,
  /// C++ enum variant: <span style='color: green;'>```AdlamScript = 134```</span>
  Adlam = 134,
  /// C++ enum variant: <span style='color: green;'>```BhaiksukiScript = 135```</span>
  Bhaiksuki = 135,
  /// C++ enum variant: <span style='color: green;'>```MarchenScript = 136```</span>
  Marchen = 136,
  /// C++ enum variant: <span style='color: green;'>```NewaScript = 137```</span>
  Newa = 137,
  /// C++ enum variant: <span style='color: green;'>```OsageScript = 138```</span>
  Osage = 138,
  /// C++ enum variant: <span style='color: green;'>```TangutScript = 139```</span>
  Tangut = 139,
  /// C++ enum variant: <span style='color: green;'>```HanWithBopomofoScript = 140```</span>
  HanWithBopomofo = 140,
  /// This variant corresponds to multiple C++ enum variants with the same value:
  ///
  /// - <span style='color: green;'>```JamoScript = 141```</span>
  /// - <span style='color: green;'>```LastScript = 141```</span>
  ///
  Jamo = 141,
}

/// C++ method: <span style='color: green;'>```qHash```</span>
///
/// This is an overloaded function. Available variants:
///
///
///
/// ## Variant 1
///
/// Rust arguments: ```fn hash(&::locale::Locale) -> ::libc::c_uint```<br>
/// C++ method: <span style='color: green;'>```unsigned int qHash(const QLocale& key)```</span>
///
///
///
/// ## Variant 2
///
/// Rust arguments: ```fn hash((&::locale::Locale, ::libc::c_uint)) -> ::libc::c_uint```<br>
/// C++ method: <span style='color: green;'>```unsigned int qHash(const QLocale& key, unsigned int seed = ?)```</span>
///
///
pub fn hash<Args>(args: Args) -> ::libc::c_uint
  where Args: overloading::HashArgs
{
  args.exec()
}
/// C++ method: <span style='color: green;'>```operator<<```</span>
///
/// This is an overloaded function. Available variants:
///
///
///
/// ## Variant 1
///
/// Rust arguments: ```fn op_shl((&'l0 mut ::data_stream::DataStream, &'l1 ::locale::Locale)) -> &'l0 mut ::data_stream::DataStream```<br>
/// C++ method: <span style='color: green;'>```QDataStream& operator<<(QDataStream& arg1, const QLocale& arg2)```</span>
///
///
///
/// ## Variant 2
///
/// Rust arguments: ```fn op_shl((&::debug::Debug, &::locale::Locale)) -> ::debug::Debug```<br>
/// C++ method: <span style='color: green;'>```QDebug operator<<(QDebug arg1, const QLocale& arg2)```</span>
///
///
pub fn op_shl<Args>(args: Args) -> Args::ReturnType
  where Args: overloading::OpShlArgs
{
  args.exec()
}
/// C++ method: <span style='color: green;'>```QDataStream& operator>>(QDataStream& arg1, QLocale& arg2)```</span>
///
///
pub fn op_shr<'l0, 'l1>(arg1: &'l0 mut ::data_stream::DataStream,
                        arg2: &'l1 mut ::locale::Locale)
                        -> &'l0 mut ::data_stream::DataStream {
  let ffi_result = unsafe {
    ::ffi::qt_core_c_QLocale_G_operator_shr(arg1 as *mut ::data_stream::DataStream,
                                            arg2 as *mut ::locale::Locale)
  };
  unsafe { ffi_result.as_mut() }.expect("Attempted to convert null pointer to reference")
}

/// C++ method: <span style='color: green;'>```void swap(QLocale& value1, QLocale& value2)```</span>
///
///
pub fn swap(value1: &mut ::locale::Locale, value2: &mut ::locale::Locale) {
  unsafe {
    ::ffi::qt_core_c_QLocale_G_swap(value1 as *mut ::locale::Locale,
                                    value2 as *mut ::locale::Locale)
  }
}

/// Types for emulating overloading for overloaded functions in this module
pub mod overloading {
  /// This trait represents a set of arguments accepted by [Locale::currency_symbol](../struct.Locale.html#method.currency_symbol) method.
  pub trait LocaleCurrencySymbolArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleCurrencySymbolArgs<'largs> for ::locale::CurrencySymbolFormat {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_currencySymbol_to_output_arg1(original_self as *const ::locale::Locale,
                                                                 arg1,
                                                                 &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleCurrencySymbolArgs<'largs> for () {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {

      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_currencySymbol_to_output_no_args(original_self as *const ::locale::Locale,
                                                                    &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::date_format](../struct.Locale.html#method.date_format) method.
  pub trait LocaleDateFormatArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleDateFormatArgs<'largs> for ::locale::FormatType {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let format = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_dateFormat_to_output_format(original_self as *const ::locale::Locale,
                                                               format,
                                                               &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleDateFormatArgs<'largs> for () {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {

      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_dateFormat_to_output_no_args(original_self as *const ::locale::Locale, &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::date_time_format](../struct.Locale.html#method.date_time_format) method.
  pub trait LocaleDateTimeFormatArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleDateTimeFormatArgs<'largs> for ::locale::FormatType {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let format = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_dateTimeFormat_to_output_format(original_self as *const ::locale::Locale,
                                                                   format,
                                                                   &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleDateTimeFormatArgs<'largs> for () {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {

      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_dateTimeFormat_to_output_no_args(original_self as *const ::locale::Locale,
                                                                    &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::day_name](../struct.Locale.html#method.day_name) method.
  pub trait LocaleDayNameArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleDayNameArgs<'largs> for ::libc::c_int {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_dayName_to_output_arg1(original_self as *const ::locale::Locale, arg1, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleDayNameArgs<'largs> for (::libc::c_int, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let format = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_dayName_to_output_arg1_format(original_self as *const ::locale::Locale,
                                                                 arg1,
                                                                 format,
                                                                 &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::month_name](../struct.Locale.html#method.month_name) method.
  pub trait LocaleMonthNameArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleMonthNameArgs<'largs> for ::libc::c_int {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_monthName_to_output_arg1(original_self as *const ::locale::Locale,
                                                            arg1,
                                                            &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleMonthNameArgs<'largs> for (::libc::c_int, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let format = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_monthName_to_output_arg1_format(original_self as *const ::locale::Locale,
                                                                   arg1,
                                                                   format,
                                                                   &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::new](../struct.Locale.html#method.new) method.
  pub trait LocaleNewArgs {
    fn exec(self) -> ::locale::Locale;
  }
  impl LocaleNewArgs for ::locale::Language {
    fn exec(self) -> ::locale::Locale {
      let language = self;
      {
        let mut object: ::locale::Locale =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_constructor_language(language, &mut object);
        }
        object
      }
    }
  }
  impl LocaleNewArgs for (::locale::Language, ::locale::Country) {
    fn exec(self) -> ::locale::Locale {
      let language = self.0;
      let country = self.1;
      {
        let mut object: ::locale::Locale =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_constructor_language_country(language, country, &mut object);
        }
        object
      }
    }
  }
  impl LocaleNewArgs for (::locale::Language, ::locale::Script, ::locale::Country) {
    fn exec(self) -> ::locale::Locale {
      let language = self.0;
      let script = self.1;
      let country = self.2;
      {
        let mut object: ::locale::Locale =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_constructor_language_script_country(language, script, country, &mut object);
        }
        object
      }
    }
  }
  impl<'a> LocaleNewArgs for &'a ::string::String {
    fn exec(self) -> ::locale::Locale {
      let name = self;
      {
        let mut object: ::locale::Locale =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_constructor_name(name as *const ::string::String, &mut object);
        }
        object
      }
    }
  }
  impl LocaleNewArgs for () {
    fn exec(self) -> ::locale::Locale {

      {
        let mut object: ::locale::Locale =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_constructor_no_args(&mut object);
        }
        object
      }
    }
  }
  impl<'a> LocaleNewArgs for &'a ::locale::Locale {
    fn exec(self) -> ::locale::Locale {
      let other = self;
      {
        let mut object: ::locale::Locale =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_constructor_other(other as *const ::locale::Locale, &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::quote_string](../struct.Locale.html#method.quote_string) method.
  pub trait LocaleQuoteStringArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleQuoteStringArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let str = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_quoteString_to_output_QString(original_self as *const ::locale::Locale,
                                                                 str as *const ::string::String,
                                                                 &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleQuoteStringArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let str = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_quoteString_to_output_QStringRef(original_self as *const ::locale::Locale,
                                                                    str as *const ::string_ref::StringRef,
                                                                    &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleQuoteStringArgs<'largs> for (&'largs ::string_ref::StringRef, ::locale::QuotationStyle) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let str = self.0;
      let style = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_quoteString_to_output_QStringRef_QLocale_QuotationStyle(original_self as *const ::locale::Locale, str as *const ::string_ref::StringRef, style, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleQuoteStringArgs<'largs> for (&'largs ::string::String, ::locale::QuotationStyle) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let str = self.0;
      let style = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_quoteString_to_output_QString_QLocale_QuotationStyle(original_self as *const ::locale::Locale, str as *const ::string::String, style, &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::standalone_day_name](../struct.Locale.html#method.standalone_day_name) method.
  pub trait LocaleStandaloneDayNameArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleStandaloneDayNameArgs<'largs> for ::libc::c_int {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_standaloneDayName_to_output_arg1(original_self as *const ::locale::Locale,
                                                                    arg1,
                                                                    &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleStandaloneDayNameArgs<'largs> for (::libc::c_int, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let format = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_standaloneDayName_to_output_arg1_format(original_self as *const ::locale::Locale,
                                                                           arg1,
                                                                           format,
                                                                           &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::standalone_month_name](../struct.Locale.html#method.standalone_month_name) method.
  pub trait LocaleStandaloneMonthNameArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleStandaloneMonthNameArgs<'largs> for ::libc::c_int {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_standaloneMonthName_to_output_arg1(original_self as *const ::locale::Locale,
                                                                      arg1,
                                                                      &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleStandaloneMonthNameArgs<'largs> for (::libc::c_int, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let format = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_standaloneMonthName_to_output_arg1_format(original_self as *const ::locale::Locale, arg1, format, &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::time_format](../struct.Locale.html#method.time_format) method.
  pub trait LocaleTimeFormatArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleTimeFormatArgs<'largs> for ::locale::FormatType {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let format = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_timeFormat_to_output_format(original_self as *const ::locale::Locale,
                                                               format,
                                                               &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleTimeFormatArgs<'largs> for () {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {

      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_timeFormat_to_output_no_args(original_self as *const ::locale::Locale, &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_currency_string0](../struct.Locale.html#method.to_currency_string0) method.
  pub trait LocaleToCurrencyString0Args<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleToCurrencyString0Args<'largs> for ::libc::c_double {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_double(original_self as *const ::locale::Locale,
                                                                     arg1,
                                                                     &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString0Args<'largs> for (::libc::c_double, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let symbol = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_double_QString(original_self as *const ::locale::Locale, arg1, symbol as *const ::string::String, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString0Args<'largs> for (::libc::c_double, &'largs ::string::String, ::libc::c_int) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let symbol = self.1;
      let precision = self.2;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_double_QString_int(original_self as *const ::locale::Locale, arg1, symbol as *const ::string::String, precision, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString0Args<'largs> for ::libc::c_int {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_int(original_self as *const ::locale::Locale,
                                                                  arg1,
                                                                  &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString0Args<'largs> for (::libc::c_int, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let symbol = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_int_QString(original_self as *const ::locale::Locale,
                                                                          arg1,
                                                                          symbol as *const ::string::String,
                                                                          &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString0Args<'largs> for u64 {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_qulonglong(original_self as *const ::locale::Locale,
                                                                         arg1,
                                                                         &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString0Args<'largs> for (u64, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let symbol = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_qulonglong_QString(original_self as *const ::locale::Locale, arg1, symbol as *const ::string::String, &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_currency_string1](../struct.Locale.html#method.to_currency_string1) method.
  pub trait LocaleToCurrencyString1Args<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleToCurrencyString1Args<'largs> for ::libc::c_float {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_float(original_self as *const ::locale::Locale,
                                                                    i,
                                                                    &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString1Args<'largs> for (::libc::c_float, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self.0;
      let symbol = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_float_QString(original_self as *const ::locale::Locale,
                                                                            i,
                                                                            symbol as *const ::string::String,
                                                                            &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString1Args<'largs> for (::libc::c_float, &'largs ::string::String, ::libc::c_int) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self.0;
      let symbol = self.1;
      let precision = self.2;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_float_QString_int(original_self as *const ::locale::Locale, i, symbol as *const ::string::String, precision, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString1Args<'largs> for i64 {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_qlonglong(original_self as *const ::locale::Locale,
                                                                        arg1,
                                                                        &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString1Args<'largs> for (i64, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let symbol = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_qlonglong_QString(original_self as *const ::locale::Locale, arg1, symbol as *const ::string::String, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString1Args<'largs> for ::libc::c_uint {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_unsigned_int(original_self as *const ::locale::Locale,
                                                                           arg1,
                                                                           &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString1Args<'largs> for (::libc::c_uint, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let symbol = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_unsigned_int_QString(original_self as *const ::locale::Locale, arg1, symbol as *const ::string::String, &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_currency_string2](../struct.Locale.html#method.to_currency_string2) method.
  pub trait LocaleToCurrencyString2Args<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleToCurrencyString2Args<'largs> for ::libc::c_short {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_short(original_self as *const ::locale::Locale,
                                                                    arg1,
                                                                    &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString2Args<'largs> for (::libc::c_short, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let symbol = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_short_QString(original_self as *const ::locale::Locale,
                                                                            arg1,
                                                                            symbol as *const ::string::String,
                                                                            &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString2Args<'largs> for ::libc::c_ushort {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_unsigned_short(original_self as *const ::locale::Locale, arg1, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToCurrencyString2Args<'largs> for (::libc::c_ushort, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let arg1 = self.0;
      let symbol = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toCurrencyString_to_output_unsigned_short_QString(original_self as *const ::locale::Locale, arg1, symbol as *const ::string::String, &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_date](../struct.Locale.html#method.to_date) method.
  pub trait LocaleToDateArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::date::Date;
  }
  impl<'largs> LocaleToDateArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::date::Date {
      let string = self;
      {
        let mut object: ::date::Date = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toDate_to_output_string(original_self as *const ::locale::Locale,
                                                           string as *const ::string::String,
                                                           &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToDateArgs<'largs> for (&'largs ::string::String, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::date::Date {
      let string = self.0;
      let arg2 = self.1;
      {
        let mut object: ::date::Date = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toDate_to_output_string_arg2(original_self as *const ::locale::Locale,
                                                                string as *const ::string::String,
                                                                arg2,
                                                                &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToDateArgs<'largs> for (&'largs ::string::String, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::date::Date {
      let string = self.0;
      let format = self.1;
      {
        let mut object: ::date::Date = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toDate_to_output_string_format(original_self as *const ::locale::Locale,
                                                                  string as *const ::string::String,
                                                                  format as *const ::string::String,
                                                                  &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_date_time](../struct.Locale.html#method.to_date_time) method.
  pub trait LocaleToDateTimeArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::date_time::DateTime;
  }
  impl<'largs> LocaleToDateTimeArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::date_time::DateTime {
      let string = self;
      {
        let mut object: ::date_time::DateTime =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toDateTime_to_output_QString(original_self as *const ::locale::Locale,
                                                                string as *const ::string::String,
                                                                &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToDateTimeArgs<'largs> for (&'largs ::string::String, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::date_time::DateTime {
      let string = self.0;
      let format = self.1;
      {
        let mut object: ::date_time::DateTime =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toDateTime_to_output_QString_QLocale_FormatType(original_self as *const ::locale::Locale, string as *const ::string::String, format, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToDateTimeArgs<'largs> for (&'largs ::string::String, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::date_time::DateTime {
      let string = self.0;
      let format = self.1;
      {
        let mut object: ::date_time::DateTime =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toDateTime_to_output_QString_QString(original_self as *const ::locale::Locale,
                                                                        string as *const ::string::String,
                                                                        format as *const ::string::String,
                                                                        &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_double](../struct.Locale.html#method.to_double) method.
  pub trait LocaleToDoubleArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_double;
  }
  impl<'largs> LocaleToDoubleArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_double {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toDouble_QString(original_self as *const ::locale::Locale,
                                                  s as *const ::string::String)
      }
    }
  }
  impl<'largs> LocaleToDoubleArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_double {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toDouble_QStringRef(original_self as *const ::locale::Locale,
                                                     s as *const ::string_ref::StringRef)
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_double_unsafe](../struct.Locale.html#method.to_double_unsafe) method.
  pub trait LocaleToDoubleUnsafeArgs<'largs> {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_double;
  }
  impl<'largs> LocaleToDoubleUnsafeArgs<'largs> for (&'largs ::string_ref::StringRef, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_double {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toDouble_QStringRef_bool(original_self as *const ::locale::Locale,
                                                        s as *const ::string_ref::StringRef,
                                                        ok)
    }
  }
  impl<'largs> LocaleToDoubleUnsafeArgs<'largs> for (&'largs ::string::String, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_double {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toDouble_QString_bool(original_self as *const ::locale::Locale,
                                                     s as *const ::string::String,
                                                     ok)
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_float](../struct.Locale.html#method.to_float) method.
  pub trait LocaleToFloatArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_float;
  }
  impl<'largs> LocaleToFloatArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_float {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toFloat_QString(original_self as *const ::locale::Locale,
                                                 s as *const ::string::String)
      }
    }
  }
  impl<'largs> LocaleToFloatArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_float {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toFloat_QStringRef(original_self as *const ::locale::Locale,
                                                    s as *const ::string_ref::StringRef)
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_float_unsafe](../struct.Locale.html#method.to_float_unsafe) method.
  pub trait LocaleToFloatUnsafeArgs<'largs> {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_float;
  }
  impl<'largs> LocaleToFloatUnsafeArgs<'largs> for (&'largs ::string_ref::StringRef, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_float {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toFloat_QStringRef_bool(original_self as *const ::locale::Locale,
                                                       s as *const ::string_ref::StringRef,
                                                       ok)
    }
  }
  impl<'largs> LocaleToFloatUnsafeArgs<'largs> for (&'largs ::string::String, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_float {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toFloat_QString_bool(original_self as *const ::locale::Locale,
                                                    s as *const ::string::String,
                                                    ok)
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_int](../struct.Locale.html#method.to_int) method.
  pub trait LocaleToIntArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_int;
  }
  impl<'largs> LocaleToIntArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_int {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toInt_QString(original_self as *const ::locale::Locale,
                                               s as *const ::string::String)
      }
    }
  }
  impl<'largs> LocaleToIntArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_int {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toInt_QStringRef(original_self as *const ::locale::Locale,
                                                  s as *const ::string_ref::StringRef)
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_int_unsafe](../struct.Locale.html#method.to_int_unsafe) method.
  pub trait LocaleToIntUnsafeArgs<'largs> {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_int;
  }
  impl<'largs> LocaleToIntUnsafeArgs<'largs> for (&'largs ::string_ref::StringRef, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_int {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toInt_QStringRef_bool(original_self as *const ::locale::Locale,
                                                     s as *const ::string_ref::StringRef,
                                                     ok)
    }
  }
  impl<'largs> LocaleToIntUnsafeArgs<'largs> for (&'largs ::string::String, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_int {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toInt_QString_bool(original_self as *const ::locale::Locale,
                                                  s as *const ::string::String,
                                                  ok)
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_long_long](../struct.Locale.html#method.to_long_long) method.
  pub trait LocaleToLongLongArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> i64;
  }
  impl<'largs> LocaleToLongLongArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> i64 {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toLongLong_QString(original_self as *const ::locale::Locale,
                                                    s as *const ::string::String)
      }
    }
  }
  impl<'largs> LocaleToLongLongArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> i64 {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toLongLong_QStringRef(original_self as *const ::locale::Locale,
                                                       s as *const ::string_ref::StringRef)
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_long_long_unsafe](../struct.Locale.html#method.to_long_long_unsafe) method.
  pub trait LocaleToLongLongUnsafeArgs<'largs> {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> i64;
  }
  impl<'largs> LocaleToLongLongUnsafeArgs<'largs> for (&'largs ::string_ref::StringRef, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> i64 {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toLongLong_QStringRef_bool(original_self as *const ::locale::Locale,
                                                          s as *const ::string_ref::StringRef,
                                                          ok)
    }
  }
  impl<'largs> LocaleToLongLongUnsafeArgs<'largs> for (&'largs ::string::String, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> i64 {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toLongLong_QString_bool(original_self as *const ::locale::Locale,
                                                       s as *const ::string::String,
                                                       ok)
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_short](../struct.Locale.html#method.to_short) method.
  pub trait LocaleToShortArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_short;
  }
  impl<'largs> LocaleToShortArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_short {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toShort_QString(original_self as *const ::locale::Locale,
                                                 s as *const ::string::String)
      }
    }
  }
  impl<'largs> LocaleToShortArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_short {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toShort_QStringRef(original_self as *const ::locale::Locale,
                                                    s as *const ::string_ref::StringRef)
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_short_unsafe](../struct.Locale.html#method.to_short_unsafe) method.
  pub trait LocaleToShortUnsafeArgs<'largs> {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_short;
  }
  impl<'largs> LocaleToShortUnsafeArgs<'largs> for (&'largs ::string_ref::StringRef, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_short {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toShort_QStringRef_bool(original_self as *const ::locale::Locale,
                                                       s as *const ::string_ref::StringRef,
                                                       ok)
    }
  }
  impl<'largs> LocaleToShortUnsafeArgs<'largs> for (&'largs ::string::String, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_short {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toShort_QString_bool(original_self as *const ::locale::Locale,
                                                    s as *const ::string::String,
                                                    ok)
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_string0](../struct.Locale.html#method.to_string0) method.
  pub trait LocaleToString0Args<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleToString0Args<'largs> for &'largs ::date::Date {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let date = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QDate(original_self as *const ::locale::Locale,
                                                            date as *const ::date::Date,
                                                            &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for &'largs ::date_time::DateTime {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let date_time = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QDateTime(original_self as *const ::locale::Locale,
                                                                date_time as *const ::date_time::DateTime,
                                                                &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for (&'largs ::date_time::DateTime, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let date_time = self.0;
      let format = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QDateTime_QLocale_FormatType(original_self as *const ::locale::Locale, date_time as *const ::date_time::DateTime, format, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for (&'largs ::date_time::DateTime, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let date_time = self.0;
      let format = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QDateTime_QString(original_self as *const ::locale::Locale,
                                                                        date_time as *const ::date_time::DateTime,
                                                                        format as *const ::string::String,
                                                                        &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for (&'largs ::date::Date, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let date = self.0;
      let format = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QDate_QLocale_FormatType(original_self as *const ::locale::Locale, date as *const ::date::Date, format, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for (&'largs ::date::Date, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let date = self.0;
      let format_str = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QDate_QString(original_self as *const ::locale::Locale,
                                                                    date as *const ::date::Date,
                                                                    format_str as *const ::string::String,
                                                                    &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for &'largs ::time::Time {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let time = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QTime(original_self as *const ::locale::Locale,
                                                            time as *const ::time::Time,
                                                            &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for (&'largs ::time::Time, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let time = self.0;
      let format = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QTime_QLocale_FormatType(original_self as *const ::locale::Locale, time as *const ::time::Time, format, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for (&'largs ::time::Time, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let time = self.0;
      let format_str = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_QTime_QString(original_self as *const ::locale::Locale,
                                                                    time as *const ::time::Time,
                                                                    format_str as *const ::string::String,
                                                                    &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for ::libc::c_double {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_double(original_self as *const ::locale::Locale, i, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for (::libc::c_double, ::libc::c_char) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self.0;
      let f = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_double_char(original_self as *const ::locale::Locale,
                                                                  i,
                                                                  f,
                                                                  &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for (::libc::c_double, ::libc::c_char, ::libc::c_int) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self.0;
      let f = self.1;
      let prec = self.2;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_double_char_int(original_self as *const ::locale::Locale,
                                                                      i,
                                                                      f,
                                                                      prec,
                                                                      &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for ::libc::c_int {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_int(original_self as *const ::locale::Locale, i, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString0Args<'largs> for u64 {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_qulonglong(original_self as *const ::locale::Locale,
                                                                 i,
                                                                 &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_string1](../struct.Locale.html#method.to_string1) method.
  pub trait LocaleToString1Args<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleToString1Args<'largs> for ::libc::c_float {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_float(original_self as *const ::locale::Locale, i, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString1Args<'largs> for (::libc::c_float, ::libc::c_char) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self.0;
      let f = self.1;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_float_char(original_self as *const ::locale::Locale,
                                                                 i,
                                                                 f,
                                                                 &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString1Args<'largs> for (::libc::c_float, ::libc::c_char, ::libc::c_int) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self.0;
      let f = self.1;
      let prec = self.2;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_float_char_int(original_self as *const ::locale::Locale,
                                                                     i,
                                                                     f,
                                                                     prec,
                                                                     &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString1Args<'largs> for i64 {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_qlonglong(original_self as *const ::locale::Locale,
                                                                i,
                                                                &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString1Args<'largs> for ::libc::c_uint {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_unsigned_int(original_self as *const ::locale::Locale,
                                                                   i,
                                                                   &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_string2](../struct.Locale.html#method.to_string2) method.
  pub trait LocaleToString2Args<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String;
  }
  impl<'largs> LocaleToString2Args<'largs> for ::libc::c_short {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_short(original_self as *const ::locale::Locale, i, &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToString2Args<'largs> for ::libc::c_ushort {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::string::String {
      let i = self;
      {
        let mut object: ::string::String =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toString_to_output_unsigned_short(original_self as *const ::locale::Locale,
                                                                     i,
                                                                     &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_time](../struct.Locale.html#method.to_time) method.
  pub trait LocaleToTimeArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::time::Time;
  }
  impl<'largs> LocaleToTimeArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::time::Time {
      let string = self;
      {
        let mut object: ::time::Time = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toTime_to_output_string(original_self as *const ::locale::Locale,
                                                           string as *const ::string::String,
                                                           &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToTimeArgs<'largs> for (&'largs ::string::String, ::locale::FormatType) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::time::Time {
      let string = self.0;
      let arg2 = self.1;
      {
        let mut object: ::time::Time = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toTime_to_output_string_arg2(original_self as *const ::locale::Locale,
                                                                string as *const ::string::String,
                                                                arg2,
                                                                &mut object);
        }
        object
      }
    }
  }
  impl<'largs> LocaleToTimeArgs<'largs> for (&'largs ::string::String, &'largs ::string::String) {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::time::Time {
      let string = self.0;
      let format = self.1;
      {
        let mut object: ::time::Time = unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_toTime_to_output_string_format(original_self as *const ::locale::Locale,
                                                                  string as *const ::string::String,
                                                                  format as *const ::string::String,
                                                                  &mut object);
        }
        object
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_u_int](../struct.Locale.html#method.to_u_int) method.
  pub trait LocaleToUIntArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_uint;
  }
  impl<'largs> LocaleToUIntArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_uint {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toUInt_QString(original_self as *const ::locale::Locale,
                                                s as *const ::string::String)
      }
    }
  }
  impl<'largs> LocaleToUIntArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_uint {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toUInt_QStringRef(original_self as *const ::locale::Locale,
                                                   s as *const ::string_ref::StringRef)
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_u_int_unsafe](../struct.Locale.html#method.to_u_int_unsafe) method.
  pub trait LocaleToUIntUnsafeArgs<'largs> {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_uint;
  }
  impl<'largs> LocaleToUIntUnsafeArgs<'largs> for (&'largs ::string_ref::StringRef, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_uint {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toUInt_QStringRef_bool(original_self as *const ::locale::Locale,
                                                      s as *const ::string_ref::StringRef,
                                                      ok)
    }
  }
  impl<'largs> LocaleToUIntUnsafeArgs<'largs> for (&'largs ::string::String, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_uint {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toUInt_QString_bool(original_self as *const ::locale::Locale,
                                                   s as *const ::string::String,
                                                   ok)
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_u_long_long](../struct.Locale.html#method.to_u_long_long) method.
  pub trait LocaleToULongLongArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> u64;
  }
  impl<'largs> LocaleToULongLongArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> u64 {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toULongLong_QString(original_self as *const ::locale::Locale,
                                                     s as *const ::string::String)
      }
    }
  }
  impl<'largs> LocaleToULongLongArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> u64 {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toULongLong_QStringRef(original_self as *const ::locale::Locale,
                                                        s as *const ::string_ref::StringRef)
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_u_long_long_unsafe](../struct.Locale.html#method.to_u_long_long_unsafe) method.
  pub trait LocaleToULongLongUnsafeArgs<'largs> {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> u64;
  }
  impl<'largs> LocaleToULongLongUnsafeArgs<'largs> for (&'largs ::string_ref::StringRef, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> u64 {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toULongLong_QStringRef_bool(original_self as *const ::locale::Locale,
                                                           s as *const ::string_ref::StringRef,
                                                           ok)
    }
  }
  impl<'largs> LocaleToULongLongUnsafeArgs<'largs> for (&'largs ::string::String, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> u64 {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toULongLong_QString_bool(original_self as *const ::locale::Locale,
                                                        s as *const ::string::String,
                                                        ok)
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_u_short](../struct.Locale.html#method.to_u_short) method.
  pub trait LocaleToUShortArgs<'largs> {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_ushort;
  }
  impl<'largs> LocaleToUShortArgs<'largs> for &'largs ::string::String {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_ushort {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toUShort_QString(original_self as *const ::locale::Locale,
                                                  s as *const ::string::String)
      }
    }
  }
  impl<'largs> LocaleToUShortArgs<'largs> for &'largs ::string_ref::StringRef {
    fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_ushort {
      let s = self;
      unsafe {
        ::ffi::qt_core_c_QLocale_toUShort_QStringRef(original_self as *const ::locale::Locale,
                                                     s as *const ::string_ref::StringRef)
      }
    }
  }
  /// This trait represents a set of arguments accepted by [Locale::to_u_short_unsafe](../struct.Locale.html#method.to_u_short_unsafe) method.
  pub trait LocaleToUShortUnsafeArgs<'largs> {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_ushort;
  }
  impl<'largs> LocaleToUShortUnsafeArgs<'largs> for (&'largs ::string_ref::StringRef, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_ushort {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toUShort_QStringRef_bool(original_self as *const ::locale::Locale,
                                                        s as *const ::string_ref::StringRef,
                                                        ok)
    }
  }
  impl<'largs> LocaleToUShortUnsafeArgs<'largs> for (&'largs ::string::String, *mut bool) {
    unsafe fn exec(self, original_self: &'largs ::locale::Locale) -> ::libc::c_ushort {
      let s = self.0;
      let ok = self.1;
      ::ffi::qt_core_c_QLocale_toUShort_QString_bool(original_self as *const ::locale::Locale,
                                                     s as *const ::string::String,
                                                     ok)
    }
  }
  /// This trait represents a set of arguments accepted by [hash](../fn.hash.html) method.
  pub trait HashArgs {
    fn exec(self) -> ::libc::c_uint;
  }
  impl<'a> HashArgs for &'a ::locale::Locale {
    fn exec(self) -> ::libc::c_uint {
      let key = self;
      unsafe { ::ffi::qt_core_c_QLocale_G_qHash_key(key as *const ::locale::Locale) }
    }
  }
  impl<'a> HashArgs for (&'a ::locale::Locale, ::libc::c_uint) {
    fn exec(self) -> ::libc::c_uint {
      let key = self.0;
      let seed = self.1;
      unsafe { ::ffi::qt_core_c_QLocale_G_qHash_key_seed(key as *const ::locale::Locale, seed) }
    }
  }
  /// This trait represents a set of arguments accepted by [op_shl](../fn.op_shl.html) method.
  pub trait OpShlArgs {
    type ReturnType;
    fn exec(self) -> Self::ReturnType;
  }
  impl<'a> OpShlArgs for (&'a mut ::data_stream::DataStream, &'a ::locale::Locale) {
    type ReturnType = &'a mut ::data_stream::DataStream;
    fn exec(self) -> &'a mut ::data_stream::DataStream {
      let arg1 = self.0;
      let arg2 = self.1;
      let ffi_result = unsafe {
        ::ffi::qt_core_c_QLocale_G_operator_shl(arg1 as *mut ::data_stream::DataStream,
                                                arg2 as *const ::locale::Locale)
      };
      unsafe { ffi_result.as_mut() }.expect("Attempted to convert null pointer to reference")
    }
  }
  impl<'a> OpShlArgs for (&'a ::debug::Debug, &'a ::locale::Locale) {
    type ReturnType = ::debug::Debug;
    fn exec(self) -> ::debug::Debug {
      let arg1 = self.0;
      let arg2 = self.1;
      {
        let mut object: ::debug::Debug =
          unsafe { ::cpp_utils::new_uninitialized::NewUninitialized::new_uninitialized() };
        unsafe {
          ::ffi::qt_core_c_QLocale_G_operator_shl_to_output(arg1 as *const ::debug::Debug,
                                                            arg2 as *const ::locale::Locale,
                                                            &mut object);
        }
        object
      }
    }
  }
}
